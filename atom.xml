<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>tonngw&#39;s Blog</title>
  
  <subtitle>开博客就要写吖！</subtitle>
  <link href="https://tonngw.com/atom.xml" rel="self"/>
  
  <link href="https://tonngw.com/"/>
  <updated>2022-07-08T14:35:49.019Z</updated>
  <id>https://tonngw.com/</id>
  
  <author>
    <name>tonngw</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剑指 Offer 62. 圆圈中最后剩下的数字</title>
    <link href="https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2062.%20%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2062.%20%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97/</id>
    <published>2022-07-08T14:32:22.273Z</published>
    <updated>2022-07-08T14:35:49.019Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。</p><p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p><p> <strong>示例 1：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 5, m = 3</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><p> <strong>示例 2：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 10, m = 17</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p> <strong>限制：</strong> </p><ul><li>$1 &lt;&#x3D; n &lt;&#x3D; 10^5$</li><li>$1 &lt;&#x3D; m &lt;&#x3D; 10^6$</li></ul><hr><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法 1"></a>算法 1</h3><h4 id="模拟环形链表-O-nm-超时"><a href="#模拟环形链表-O-nm-超时" class="headerlink" title="(模拟环形链表)  $O(nm)$ 超时"></a>(模拟环形链表)  $O(nm)$ 超时</h4><p>用 $list$ 模拟环形链表，由于 $list$ 不是环形结构，所以当迭代器走到链表末尾时，需要让其转到链表头部形成环</p><p>每次从迭代器指向的数开始数，数 $m$ 次找到第 $m$ 个数，将其删除，接着再从下一个位置开始数，循环此过程，直到环中只剩下一个数，就是答案</p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>环中总共有 $n$ 个数字，需要删掉 $n - 1$ 个数才能得到答案，每删除一个数需要迭代器移动 $m - 1$ 次，所以时间复杂度为 $O(nm)$</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>$O(n)$</p><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a href="https://www.ac_wing.com/solution/content/796/">https://www.ac_wing.com/solution/content/796/</a></p><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">        list&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) nums.<span class="built_in">push_back</span>(i);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从头开始报数，除去当前数外，还需循环 m - 1 次找到第 m 个数</span></span><br><span class="line">        <span class="keyword">auto</span> it = nums.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="type">int</span> k = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (nums.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (k -- )</span><br><span class="line">            &#123;</span><br><span class="line">                it ++ ;</span><br><span class="line">                <span class="comment">// 如果迭代器走到末尾将其移到开头继续寻找，形成环形链表</span></span><br><span class="line">                <span class="keyword">if</span> (it == nums.<span class="built_in">end</span>()) it = nums.<span class="built_in">begin</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 删除当前迭代器指定位置上的元素，返回下一个位置的迭代器</span></span><br><span class="line">            it = nums.<span class="built_in">erase</span>(it);</span><br><span class="line">            <span class="keyword">if</span> (it == nums.<span class="built_in">end</span>()) it = nums.<span class="built_in">begin</span>();</span><br><span class="line">            k = m - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.<span class="built_in">front</span>();        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法 2"></a>算法 2</h3><h4 id="推导递推式-O-n-2"><a href="#推导递推式-O-n-2" class="headerlink" title="(推导递推式)  $O(n^2)$"></a>(推导递推式)  $O(n^2)$</h4><p>首先我们应该知道 $f[i, m]$ 的含义是 $i$ 个数字中删除第 $m$ 个数字</p><p>$f(n, m)$ 表示 $n$ 个数字删除第 $m$ 个数字，删除 $m - 1$，此时圆中的数字为 $(0, 1, 2, … m - 2, m,  m + 1 .. n - 1)$ (m - 1 被删掉了)<br>$f(n - 1, m)$ 表示 $n - 1$ 个数字中删除第 $m$ 个数字，开始数数前此时圆中的数字为 $(m, m + 1, m + 2 … n - 1, n[0], n + 1[1], n + 2[2]…) % n$<br>观察两组数字，可得递推式：<code>f(n, m) = (f(n - 1, m) + m) % n</code></p><p>边界：当 <code>n = 1</code> 时圆中只有一个数字 $0$，返回 $0$ 即可</p><h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>由 $f[1, m] &#x3D; 0$ 递推 $n - 1$ 次就可以得到 $f[n, m]$，所以时间复杂度为 $O(n)$</p><h4 id="C-代码-1"><a href="#C-代码-1" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">lastRemaining</span>(n - <span class="number">1</span>, m) + m) % n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求</summary>
      
    
    
    
    <category term="算法" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指 Offer" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87-Offer/"/>
    
    
    <category term="数学" scheme="https://tonngw.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="环形链表" scheme="https://tonngw.com/tags/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 44. 数字序列中某一位的数字</title>
    <link href="https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2044.%20%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2044.%20%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97/</id>
    <published>2022-07-08T14:32:11.069Z</published>
    <updated>2022-07-08T14:34:42.630Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。</p><p>请写一个函数，求任意第n位对应的数字。</p><p> <strong>示例 1：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p> <strong>示例 2：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 11</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p> <strong>限制：</strong> </p><ul><li>$0 &lt;&#x3D; n &lt; 2^31$</li></ul><p>注意：本题与主站 400 题相同：<a href="https://leetcode-cn.com/problems/nth-digit/">https://leetcode-cn.com/problems/nth-digit/</a></p><hr><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="数位统计-O-logn"><a href="#数位统计-O-logn" class="headerlink" title="(数位统计) $O(logn)$"></a>(数位统计) $O(logn)$</h4><p>首先我们知道的是，1 位数有 10 个，2 位数有 9 个，3 位数有 9 * 10 个，4 位数有 9 * 100 个</p><p>注意：从 1 开始计数；先不考虑 0，那么一位数就变成 9 个</p><p>三步操作</p><ol><li>确定是几位数，比如是三位数</li><li>确定是几位数的第几个数，比如是三位数的第 20 个数，即 100 + 20 - 1 &#x3D; 119。</li><li>确定属于那个数的第几位</li></ol><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>总的时间复杂度即三步操作的时间复杂度</p><ol><li>int 的范围 $2*10^9$，所以最多是 10 位数，因此第一步操作的时间是 $O(1)$ 的</li><li>第二步除法向上取整，也是 $O(1)$ 的</li><li>第三步求是第几位数字是 $O(log_{10}n)$ 的<br>在二进制表示中取某一位可以每次右移 1 位（即除以 2），所以是 $O(log_2n)$ 级别的，<br>同理在十进制中取某一位可以每次右移 1 位（即除以 10），所以是 $O(log_{10}n)$ 级别的</li></ol><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>$O(1)$</p><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// n ++ ; // 题目是从 0 开始计数，我们的思路是从 1 开始计数，相等于把 0 算到里面了，所以 n 往后移一位</span></span><br><span class="line">        <span class="comment">// n -- ; // 先不考虑 0，debug 之后发现 0 也满足不需要加特判</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// i 表示几位数，s 表示 i 位数有几个，base 表示第 i 位数的第一个数是谁</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> i = <span class="number">1</span>, s = <span class="number">9</span>, base = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 确定是几位数</span></span><br><span class="line">        <span class="keyword">while</span> (n &gt; i * s) &#123;</span><br><span class="line">            n -= i * s;</span><br><span class="line">            i ++ ;</span><br><span class="line">            s *= <span class="number">10</span>;</span><br><span class="line">            base *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 循环结束 n 存的就是第 i 位数的第几位</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 确定是 i 位数的第几个数：(n + i - 1) / i，需要向上取整，如果有余数说明是下一个数</span></span><br><span class="line">        <span class="comment">// number 存的就是这个数</span></span><br><span class="line">        <span class="type">int</span> number = base + (n + i - <span class="number">1</span>) / i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 求余数（第几位），如果 r = 0 表示是最后一位（也就是 i，几位数就是几），如果 r = 1 表示是第一位 ... 依此类推</span></span><br><span class="line">        <span class="type">int</span> r = n % i ? n % i : i;</span><br><span class="line">        <span class="comment">// 3. 取出这一位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i - r; j ++ ) number /= <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 如果是 1 位数，个位就是答案，如果是多位数，经过第 3 步处理，个位也就是答案</span></span><br><span class="line">        <span class="keyword">return</span> number % <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是</summary>
      
    
    
    
    <category term="算法" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指 Offer" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87-Offer/"/>
    
    
    <category term="数学" scheme="https://tonngw.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="数位统计" scheme="https://tonngw.com/tags/%E6%95%B0%E4%BD%8D%E7%BB%9F%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 43. 1～n 整数中 1 出现的次数</title>
    <link href="https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2043.%201%EF%BD%9En%20%E6%95%B4%E6%95%B0%E4%B8%AD%201%20%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/"/>
    <id>https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2043.%201%EF%BD%9En%20%E6%95%B4%E6%95%B0%E4%B8%AD%201%20%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</id>
    <published>2022-07-08T14:32:04.434Z</published>
    <updated>2022-07-08T14:34:49.190Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个整数 $n$ ，求1～n这n个整数的十进制表示中1出现的次数。</p><p>例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。</p><p> <strong>示例 1：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 12</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><p> <strong>示例 2：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 13</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure><p> <strong>限制：</strong> </p><ul><li>$1 &lt;&#x3D; n &lt; 2^31$</li></ul><p>注意：本题与主站 233 题相同：<a href="https://leetcode-cn.com/problems/number-of-digit-one/">https://leetcode-cn.com/problems/number-of-digit-one/</a></p><hr><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="数位统计-O-log-10-n"><a href="#数位统计-O-log-10-n" class="headerlink" title="(数位统计)  $O(log_{10}n)$"></a>(数位统计)  $O(log_{10}n)$</h4><p>分情况讨论<br>假设当前枚举到了第 i 位，left 表示 i 左边数字，right 表示 i 右边数字</p><ol><li>左边数字是 0 ~ (ab - 1)，出现次数 ab * t（假设当前枚举位右边数字的位数为 x，则 $t &#x3D; 10^x$</li><li>左边数字是 ab<br> 2.1 当前位是 0，不做处理<br> 2.2 当前位是 1，出现次数 right + 1<br> 2.3 当前位大于 1，出现次数 t</li></ol><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>两次循环枚举每一位，所以时间复杂度为 $O(log_{10}n)$。</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>$O(1)$</p><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; number;</span><br><span class="line">        <span class="keyword">while</span> (n) number.<span class="built_in">push_back</span>(n % <span class="number">10</span>), n /= <span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 从最高位开始枚举</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = number.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) &#123;</span><br><span class="line">            <span class="comment">// left: i 左边数字，right: i 右边数字，t: right 有几位，t 就是 10 的几次方</span></span><br><span class="line">            <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, t = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 求正在枚举的当前位的左边数字</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = number.<span class="built_in">size</span>() - <span class="number">1</span>; j &gt; i; j -- ) left = left * <span class="number">10</span> + number[j];</span><br><span class="line">            <span class="comment">// 求正在枚举的当前位的右边数字</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j -- ) right = right * <span class="number">10</span> + number[j], t *= <span class="number">10</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 1. 左边数字是 0 ~ (ab - 1)</span></span><br><span class="line">            res += left * t;</span><br><span class="line">            <span class="comment">// 2. 左边数字是 ab</span></span><br><span class="line">            <span class="comment">// 2.1 当前位是 0，不做处理</span></span><br><span class="line">            <span class="comment">// 2.2 当前位是 1</span></span><br><span class="line">            <span class="keyword">if</span> (number[i] == <span class="number">1</span>) res += right + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 2.3 当前位大于 1</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (number[i] &gt; <span class="number">1</span>) res += t;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;输入一个整数 $n$ ，求1～n这n个整数的十进制表示中1出现的次数。&lt;/p&gt;
&lt;p&gt;例如，输入12，1～12这些整数中包含</summary>
      
    
    
    
    <category term="算法" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指 Offer" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87-Offer/"/>
    
    
    <category term="数学" scheme="https://tonngw.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="数位统计" scheme="https://tonngw.com/tags/%E6%95%B0%E4%BD%8D%E7%BB%9F%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 14- II. 剪绳子 II</title>
    <link href="https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2014-%20II.%20%E5%89%AA%E7%BB%B3%E5%AD%90%20II/"/>
    <id>https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2014-%20II.%20%E5%89%AA%E7%BB%B3%E5%AD%90%20II/</id>
    <published>2022-07-08T14:31:54.750Z</published>
    <updated>2022-07-08T14:33:05.553Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一根长度为 $n$ 的绳子，请把绳子剪成整数长度的 $m$ 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 $k[0],k[1]…k[m - 1]$ 。请问 $k[0]<em>k[1]</em>…*k[m - 1]$ 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p> <strong>示例 1：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 = 1 + 1, 1 × 1 = 1</span><br></pre></td></tr></table></figure><p> <strong>示例 2:</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong> </p><ul><li>$2 &lt;&#x3D; n &lt;&#x3D; 1000$</li></ul><p>注意：本题与主站 343 题相同：<a href="https://leetcode-cn.com/problems/integer-break/">https://leetcode-cn.com/problems/integer-break/</a></p><hr><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="数学-O-n"><a href="#数学-O-n" class="headerlink" title="(数学)  $O(n)$"></a>(数学)  $O(n)$</h4><p>思路和 <a href="https://leetcode.cn/problems/jian-sheng-zi-lcof/solution/jian-zhi-offer-14-i-jian-sheng-zi-by-ton-dfeu/">剑指 Offer 14- I. 剪绳子</a> 一样，只是 $n$ 的范围扩大成了 $1000$，在做乘法的时候 $res$ 需要转成 $long long$ 防止爆 $int$。</p><p>在代码实现上换了一种写法。</p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>$O(n)$</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>$O(1)$</p><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">3</span>) <span class="keyword">return</span> <span class="number">1</span> * (n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt;= <span class="number">5</span>)  res = (<span class="type">long</span> <span class="type">long</span>)res * <span class="number">3</span> % mod, n -= <span class="number">3</span>; <span class="comment">// 先拆 3</span></span><br><span class="line">        res = (<span class="type">long</span> <span class="type">long</span>)res * n % mod; <span class="comment">// 剩下的就是 4 或 2</span></span><br><span class="line">        <span class="keyword">if</span> (res == <span class="number">1000000008</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;给你一根长度为 $n$ 的绳子，请把绳子剪成整数长度的 $m$ 段（m、n都是整数，n&amp;gt;1并且m&amp;gt;1），每段绳子</summary>
      
    
    
    
    <category term="算法" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指 Offer" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87-Offer/"/>
    
    
    <category term="数学" scheme="https://tonngw.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 14- I. 剪绳子</title>
    <link href="https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2014-%20I.%20%E5%89%AA%E7%BB%B3%E5%AD%90/"/>
    <id>https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2014-%20I.%20%E5%89%AA%E7%BB%B3%E5%AD%90/</id>
    <published>2022-07-08T14:31:01.872Z</published>
    <updated>2022-07-08T14:31:48.545Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一根长度为 $n$ 的绳子，请把绳子剪成整数长度的 $m$ 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 $k[0],k[1]…k[m-1]$ 。请问 $k[0]<em>k[1]</em>…*k[m-1]$ 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><p> <strong>示例 1：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 = 1 + 1, 1 × 1 = 1</span><br></pre></td></tr></table></figure><p> <strong>示例 2:</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong> </p><ul><li>$2 &lt;&#x3D; n &lt;&#x3D; 58$</li></ul><p>注意：本题与主站 343 题相同：<a href="https://leetcode-cn.com/problems/integer-break/">https://leetcode-cn.com/problems/integer-break/</a></p><hr><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="数学-O-n"><a href="#数学-O-n" class="headerlink" title="(数学)  $O(n)$"></a>(数学)  $O(n)$</h4><p>拆分原则：尽可能的拆出多个 3</p><p>四部曲：</p><ol><li>如果 $n &lt;&#x3D; 3$ 拆成 $1$ 和 $n - 1$</li><li>如果 $n % 3 &#x3D;&#x3D; 1$ 拆出一个 $4$</li><li>如果 $n % 3 &#x3D;&#x3D; 2$ 拆出一个 $2$</li><li>最后剩下的全拆成 $3$</li></ol><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>$O(n)$</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>$O(1)$</p><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">3</span>) <span class="keyword">return</span> <span class="number">1</span> * (n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">1</span>) res *= <span class="number">4</span>, n -= <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">2</span>) res *= <span class="number">2</span>, n -= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) res *= <span class="number">3</span>, n -= <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;给你一根长度为 $n$ 的绳子，请把绳子剪成整数长度的 $m$ 段（m、n都是整数，n&amp;gt;1并且m&amp;gt;1），每段绳子</summary>
      
    
    
    
    <category term="算法" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指 Offer" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87-Offer/"/>
    
    
    <category term="数学" scheme="https://tonngw.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>面试题40. 最小的k个数</title>
    <link href="https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E9%9D%A2%E8%AF%95%E9%A2%9840.%20%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/"/>
    <id>https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E9%9D%A2%E8%AF%95%E9%A2%9840.%20%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/</id>
    <published>2022-07-08T14:29:06.312Z</published>
    <updated>2022-07-08T14:30:35.123Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入整数数组 $arr$ ，找出其中最小的 $k$ 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p><p> <strong>示例 1：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [3,2,1], k = 2</span><br><span class="line">输出：[1,2] 或者 [2,1]</span><br></pre></td></tr></table></figure><p> <strong>示例 2：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [0,1,2,1], k = 1</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p> <strong>限制：</strong> </p><ul><li>$0 &lt;&#x3D; k &lt;&#x3D; arr.length &lt;&#x3D; 10000$</li><li>$0 &lt;&#x3D; arr[i] &lt;&#x3D; 10000$</li></ul><hr><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="堆-O-n"><a href="#堆-O-n" class="headerlink" title="(堆))  $O(n)$"></a>(堆))  $O(n)$</h4><p>使用大根堆存储 $k$ 个最小的数，怎么存呢，遍历每个数，先加到大根堆中，如果堆的大小大于 $k$ 则弹出一个堆顶，所以数都遍历完后，此时堆中存的就是最小的 $k$ 个数。</p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>$O(n)$</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>$O(n)$</p><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>&gt; heap;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : arr) &#123;</span><br><span class="line">            heap.<span class="built_in">push</span>(x);</span><br><span class="line">            <span class="keyword">if</span> (heap.<span class="built_in">size</span>() &gt; k)</span><br><span class="line">                heap.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (heap.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(heap.<span class="built_in">top</span>());</span><br><span class="line">            heap.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;输入整数数组 $arr$ ，找出其中最小的 $k$ 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数</summary>
      
    
    
    
    <category term="算法" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指 Offer" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87-Offer/"/>
    
    
    <category term="堆" scheme="https://tonngw.com/tags/%E5%A0%86/"/>
    
    <category term="优先队列" scheme="https://tonngw.com/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 41. 数据流中的中位数</title>
    <link href="https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2041.%20%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2041.%20%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</id>
    <published>2022-07-08T14:28:56.101Z</published>
    <updated>2022-07-08T14:30:49.597Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p><p>例如，</p><p>[2,3,4] 的中位数是 3</p><p>[2,3] 的中位数是 (2 + 3) &#x2F; 2 &#x3D; 2.5</p><p>设计一个支持以下两种操作的数据结构：</p><ul><li>void addNum(int num) - 从数据流中添加一个整数到数据结构中。</li><li>double findMedian() - 返回目前所有元素的中位数。</li></ul><p> <strong>示例 1：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</span><br><span class="line">[[],[1],[2],[],[3],[]]</span><br><span class="line">输出：[null,null,null,1.50000,null,2.00000]</span><br></pre></td></tr></table></figure><p> <strong>示例 2：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</span><br><span class="line">[[],[2],[],[3],[]]</span><br><span class="line">输出：[null,null,2.00000,null,2.50000]</span><br></pre></td></tr></table></figure><p> <strong>限制：</strong> </p><ul><li>最多会对 $addNum、findMedian$ 进行 $50000$ 次调用。</li></ul><p>注意：本题与主站 295 题相同：<a href="https://leetcode-cn.com/problems/find-median-from-data-stream/">https://leetcode-cn.com/problems/find-median-from-data-stream/</a></p><hr><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="对顶堆-O-n"><a href="#对顶堆-O-n" class="headerlink" title="(对顶堆)  $O(n)$"></a>(对顶堆)  $O(n)$</h4><p>用 <code>小根堆 + 大根堆</code> 结构来维护中位数，大根堆存储比较小的一部分数，小根堆存储比较大的一部分数。<br>需要维护结构中小根堆的元素个数最多比大根堆元素个数多 $1$。<br>如果数的个数是奇数，中位数就是小根堆堆顶，如果是偶数，中位数就是小根堆堆顶和大根堆堆顶之和 &#x2F; 2。</p><p>代码实现技巧：每次先把元素添加到小根堆中，如果小根堆堆顶比大根堆堆顶大，构成逆序就需要交换，且要保证小根堆的元素个数最多比大根堆元素个数多 $1$，超过 $1$ 则需要将其堆顶弹出并插入到大根堆中。</p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>每次往堆中插入元素的时间复杂度为 $O(1)$，求中位数的时间也是 $O(1)$，所以总时间复杂度为 $O(n)$</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>$O(n)$</p><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; max_heap;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; min_heap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MedianFinder</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addNum</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        min_heap.<span class="built_in">push</span>(num);</span><br><span class="line">        <span class="keyword">if</span> (min_heap.<span class="built_in">size</span>() &gt; max_heap.<span class="built_in">size</span>() + <span class="number">1</span>) &#123;</span><br><span class="line">            max_heap.<span class="built_in">push</span>(min_heap.<span class="built_in">top</span>());</span><br><span class="line">            min_heap.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (max_heap.<span class="built_in">size</span>() &amp;&amp; min_heap.<span class="built_in">top</span>() &lt; max_heap.<span class="built_in">top</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> minv = min_heap.<span class="built_in">top</span>(), maxv = max_heap.<span class="built_in">top</span>();</span><br><span class="line">            min_heap.<span class="built_in">push</span>(maxv), max_heap.<span class="built_in">push</span>(minv);</span><br><span class="line">            min_heap.<span class="built_in">pop</span>(), max_heap.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((min_heap.<span class="built_in">size</span>() + max_heap.<span class="built_in">size</span>()) &amp; <span class="number">1</span>) <span class="keyword">return</span> min_heap.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">return</span> (min_heap.<span class="built_in">top</span>() + max_heap.<span class="built_in">top</span>()) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MedianFinder object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MedianFinder* obj = new MedianFinder();</span></span><br><span class="line"><span class="comment"> * obj-&gt;addNum(num);</span></span><br><span class="line"><span class="comment"> * double param_2 = obj-&gt;findMedian();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出</summary>
      
    
    
    
    <category term="算法" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指 Offer" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87-Offer/"/>
    
    
    <category term="堆" scheme="https://tonngw.com/tags/%E5%A0%86/"/>
    
    <category term="对顶堆" scheme="https://tonngw.com/tags/%E5%AF%B9%E9%A1%B6%E5%A0%86/"/>
    
    <category term="优先队列" scheme="https://tonngw.com/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 57. 和为s的两个数字</title>
    <link href="https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2057.%20%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/"/>
    <id>https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2057.%20%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/</id>
    <published>2022-07-08T14:27:17.035Z</published>
    <updated>2022-07-08T14:28:42.817Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p><p> <strong>示例 1：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[2,7] 或者 [7,2]</span><br></pre></td></tr></table></figure><p> <strong>示例 2：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [10,26,30,31,47,60], target = 40</span><br><span class="line">输出：[10,30] 或者 [30,10]</span><br></pre></td></tr></table></figure><p> <strong>限制：</strong> </p><ul><li>$1 &lt;&#x3D; nums.length &lt;&#x3D; 10^5$</li><li>$1 &lt;&#x3D; nums[i] &lt;&#x3D; 10^6$</li></ul><hr><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="哈希表-O-n"><a href="#哈希表-O-n" class="headerlink" title="(哈希表)  $O(n)$"></a>(哈希表)  $O(n)$</h4><p>遍历数组，用哈希表存储每个元素以及出现次数，如果 $target - nums[i]$ 在哈希表中存在，那么数组中和为目标值 $target$ 的两个数就是 $target - nums[i]、nums[i]$。</p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>遍历一次数组的时间是 $O(n)$ 的，哈希表的操作是 $O(1)$ 的，所以总时间复杂度为 $O(n)$</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>需要额外 $O(n)$ 的空间用于哈希表存储 $nums$ 中每个元素及出现次数。</p><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash[target - x]) <span class="keyword">return</span> &#123;target - x, x&#125;;</span><br><span class="line">            hash[x] ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</summary>
      
    
    
    
    <category term="算法" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指 Offer" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87-Offer/"/>
    
    
    <category term="哈希表" scheme="https://tonngw.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 50. 第一个只出现一次的字符</title>
    <link href="https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2050.%20%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/"/>
    <id>https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2050.%20%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/</id>
    <published>2022-07-08T14:27:01.743Z</published>
    <updated>2022-07-08T14:28:18.913Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</p><p> <strong>示例 1:</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abaccdeff&quot;</span><br><span class="line">输出：&#x27;b&#x27;</span><br></pre></td></tr></table></figure><p> <strong>示例 2:</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;&quot; </span><br><span class="line">输出：&#x27; &#x27;</span><br></pre></td></tr></table></figure><p> <strong>限制：</strong> </p><p>$0 &lt;&#x3D; s 的长度 &lt;&#x3D; 50000$</p><hr><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="哈希表-O-n"><a href="#哈希表-O-n" class="headerlink" title="(哈希表)  $O(n)$"></a>(哈希表)  $O(n)$</h4><ol><li>遍历一遍字符串用哈希表存储每个字符出现的次数</li><li>再遍历一遍字符串遇到只出现一次的字符返回即可，否则返回 <code>#</code></li></ol><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>字符串被遍历两次，时间复杂度为 $O(n)$</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>$O(n)$</p><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">firstUniqChar</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : s) cnt[c] ++ ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : s) </span><br><span class="line">            <span class="keyword">if</span> (cnt[c] == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。&lt;/p&gt;
&lt;p&gt; &lt;strong</summary>
      
    
    
    
    <category term="算法" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指 Offer" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87-Offer/"/>
    
    
    <category term="哈希表" scheme="https://tonngw.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 68 - II. 二叉树的最近公共祖先</title>
    <link href="https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2068%20-%20II.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <id>https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2068%20-%20II.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</id>
    <published>2022-07-08T14:15:35.703Z</published>
    <updated>2022-07-08T14:26:46.431Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（ <strong>一个节点也可以是它自己的祖先</strong> ）。”</p><p>例如，给定如下二叉树:  root &#x3D; [3,5,1,6,2,0,8,null,null,7,4]</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/binarytree.png"></p><p> <strong>示例 1:</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span><br><span class="line">输出: 3</span><br><span class="line">解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</span><br></pre></td></tr></table></figure><p> <strong>示例 2:</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4</span><br><span class="line">输出: 5</span><br><span class="line">解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure><p> <strong>说明:</strong> </p><ul><li>所有节点的值都是唯一的。</li><li>p、q 为不同节点且均存在于给定的二叉树中。</li></ul><p>注意：本题与主站 236 题相同：<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/</a></p><hr><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h3 id="递归-O-n"><a href="#递归-O-n" class="headerlink" title="(递归)  $O(n)$"></a>(递归)  $O(n)$</h3><p>求公共祖先需要自底向上递归遍历二叉树，那么可以按照后序顺序遍历。</p><p><strong>题目已知 $p$ 和 $q$ 一定在二叉树中</strong>，所以一定存在非空答案。</p><p>递归三部曲：</p><ol><li>递归函数的含义：直接使用题目给出的函数，返回以 $root$ 为根节点二叉树中节点 $p$ 和 $q$ 的最近公共祖先，返回值就是最近公共祖先。<strong>返回值总共有四种情况</strong>：<ul><li>如果以 root 为根的子树中包含 p 和 q，则返回它们的最近公共祖先即 root</li><li>如果只包含 p，返回 p</li><li>如果只包含 q，返回 q</li><li>如果都不包含，则返回 NULL</li></ul></li><li>递归出口条件：如果当前节点 $root$ 为空或等于 $p$ 或等于 $q$，直接返回当前节点即可。<ul><li>如果 <code>root == NULL</code> 说明没找到 p 或 q，返回 NULL 即可</li><li>如果 <code>root == p</code> 说明当前树包含 p，p 是它自己的最近公共祖先，返回 p</li><li>如果 <code>root == q</code> 说明当前树包含 q，q 是它自己的最近公共祖先，返回 q</li></ul></li><li>单层递归逻辑：递归查找左子树中 $p$ 和 $q$ 的最近公共祖先 $left$，递归查找右子树中 $p$ 和 $q$ 的最近公共祖先 $right$，所以对于 $left$ 和 $right$ 有四种情况：<ul><li>如果 $left$ 为空，最近公共祖先一定在右子树中，返回 $right$ 即可。</li><li>如果 $right$ 为空，最近公共祖先一定在左子树中，返回 $left$ 即可。</li><li>如果 $left$ 和 $right$ 都不为空，则返回当前节点</li><li>如果 $left$ 和 $right$ 都为空，则返回空，这种情况可以在第一种情况中得到处理。</li></ul></li></ol><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>二叉树中的每个节点只需被遍历一次，所以时间复杂度为 $O(n)$。</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>最坏情况下二叉树呈链状，需要 $O(n)$ 的空间。</p><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == root || q == root || !root) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">auto</span> left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">        <span class="keyword">auto</span> right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">if</span> (!left) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">if</span> (!right) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://baike.bai</summary>
      
    
    
    
    <category term="算法" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指 Offer" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87-Offer/"/>
    
    
    <category term="DFS" scheme="https://tonngw.com/tags/DFS/"/>
    
    <category term="二叉搜索树" scheme="https://tonngw.com/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</title>
    <link href="https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2068%20-%20I.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <id>https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2068%20-%20I.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</id>
    <published>2022-07-08T14:15:28.657Z</published>
    <updated>2022-07-08T14:25:46.445Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（ <strong>一个节点也可以是它自己的祖先</strong> ）。”</p><p>例如，给定如下二叉搜索树:  root &#x3D; [6,2,8,0,4,7,9,null,null,3,5]</p><p><img src="https://blog-1255494775.cos.ap-beijing.myqcloud.com/binarysearchtree_improved.png"></p><p> <strong>示例 1:</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 节点 2 和节点 8 的最近公共祖先是 6。</span><br></pre></td></tr></table></figure><p> <strong>示例 2:</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4</span><br><span class="line">输出: 2</span><br><span class="line">解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure><p> <strong>说明:</strong> </p><ul><li>所有节点的值都是唯一的。</li><li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li></ul><p>注意：本题与主站 235 题相同：<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/</a></p><hr><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法 1"></a>算法 1</h3><h4 id="递归-O-h"><a href="#递归-O-h" class="headerlink" title="(递归)  $O(h)$"></a>(递归)  $O(h)$</h4><p>这道题目完全可以使用查找二叉树的最近公共祖先的方法去做，但是这种做法的时间复杂度是 $O(n)$ 的，需要遍历整棵二叉树。对于二叉搜索树要充分利用它的有序特性，可以将时间复杂度优化为 $O(h)$。</p><p>由于二叉搜索树的有序性，从上往下遍历会比较方便，左边的都比根节点小，右边的都比根节点大。</p><p>递归三部曲：</p><ol><li>递归函数的含义：返回以 $root$ 为根节点的包含 $p$ 和 $q$ 的最近公共祖先，如果只包含一个就返回一个。</li><li>递归出口条件：如果当前节点为空，返回 NULL，但题目已知肯定存在答案，从上往下遍历的过程中不可能走到空节点，所以可以没有递归出口条件。</li><li>单层递归逻辑：<ul><li>如果 $p$ 的值比 $q$ 大，为了方便操作，首先交换一下两个节点的值，保证 $p$ 的值小于 $q$ 的值。 </li><li>如果当前节点的值大于等于 $p$ 的值且小于等于 $q$ 的值，那么当前节点就是 $p$ 和 $q$ 的最近公共祖先。</li><li>如果当前节点的值大于等于 $p$ 的值和 $q$ 的值，说明答案一定在左子树中，所以递归搜索左子树。否则如果当前节点的值小于等于 $p$ 的值和 $q$ 的值，说明答案一定在右子树中，所以递归搜索右子树。</li></ul></li></ol><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>由于二叉搜索树的有序性，答案要么在左边要么在右边，最坏情况下只需遍历从头节点到叶子节点的一条链，所以时间复杂度为 $O(h)$，$h$ 为二叉搜索树的高度。</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>$O(n)$</p><h3 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;val &gt; q-&gt;val) <span class="built_in">swap</span>(p, q);</span><br><span class="line">        <span class="comment">// 这里要加等于，因为当前节点可能是 p 或者 q，即 p 可能是 q 的祖先或者 q 是 p 的祖先</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;val &lt;= root-&gt;val &amp;&amp; root-&gt;val &lt;= q-&gt;val) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;val &lt; root-&gt;val &amp;&amp; q-&gt;val &lt; root-&gt;val) <span class="keyword">return</span> <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法 2"></a>算法 2</h3><h4 id="迭代-O-h"><a href="#迭代-O-h" class="headerlink" title="(迭代)  $O(h)$"></a>(迭代)  $O(h)$</h4><p>由于二叉搜索树的有序性，从根节点开始往下搜索，一定能找到答案。思路和递归是一样的。</p><h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>由于二叉搜索树的有序性，答案要么在左边要么在右边，最坏情况下只需遍历从头节点到叶子节点的一条链，所以时间复杂度为 $O(h)$，$h$ 为二叉搜索树的高度。</p><h4 id="空间复杂度-1"><a href="#空间复杂度-1" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>$O(1)$</p><h3 id="C-代码-1"><a href="#C-代码-1" class="headerlink" title="C++ 代码"></a>C++ 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (root) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val) root = root-&gt;left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val) root = root-&gt;right;</span><br><span class="line">            <span class="comment">// 不管 p 和 q 谁大，root 都是它们的最近公共祖先</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://baike.b</summary>
      
    
    
    
    <category term="算法" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指 Offer" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87-Offer/"/>
    
    
    <category term="递归" scheme="https://tonngw.com/tags/%E9%80%92%E5%BD%92/"/>
    
    <category term="迭代" scheme="https://tonngw.com/tags/%E8%BF%AD%E4%BB%A3/"/>
    
    <category term="二叉搜索树" scheme="https://tonngw.com/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 55 - II. 平衡二叉树</title>
    <link href="https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2055%20-%20II.%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2055%20-%20II.%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2022-07-08T14:15:13.864Z</published>
    <updated>2022-07-08T14:24:48.275Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p><p> <strong>示例 1:</strong> </p><p>给定二叉树 $[3,9,20,null,null,15,7]$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回 $true$ 。  </p><p> <strong>示例 2:</strong> </p><p>给定二叉树 $[1,2,2,3,3,null,null,4,4]$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">       1</span><br><span class="line">     / \</span><br><span class="line">    2   2</span><br><span class="line">   / \</span><br><span class="line">  3   3</span><br><span class="line"> / \</span><br><span class="line">4   4</span><br></pre></td></tr></table></figure><p>返回 $false$ 。</p><p> <strong>限制：</strong> </p><ul><li>$0 &lt;&#x3D; 树的结点个数 &lt;&#x3D; 10000$</li></ul><p>注意：本题与主站 110 题相同：<a href="https://leetcode-cn.com/problems/balanced-binary-tree/">https://leetcode-cn.com/problems/balanced-binary-tree/</a></p><hr><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法 1"></a>算法 1</h3><h4 id="DFS-递归-O-n"><a href="#DFS-递归-O-n" class="headerlink" title="(DFS,递归)  $O(n)$"></a>(DFS,递归)  $O(n)$</h4><p>这道题目其实就是在求二叉树中的每个节点最大深度（高度）的过程中判断以当前节点为根的树是否为二叉平衡树。</p><p>定义一个全局答案，首先假设是平衡二叉树，递归后序遍历二叉树，遍历的过程中如果遇到不是平衡二叉树的节点，说明整棵二叉树就不是平衡二叉树。</p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>二叉树的每个节点只会被遍历一次，所以时间复杂度为 $O(n)$。</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>$O(logn)$，最坏情况下 $O(n)$。</p><h3 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">bool</span> ans = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> lh = <span class="built_in">dfs</span>(root-&gt;left), rh = <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(lh - rh) &gt; <span class="number">1</span>) ans = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(lh, rh) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法 2"></a>算法 2</h3><h4 id="BFS-迭代-O-n-2"><a href="#BFS-迭代-O-n-2" class="headerlink" title="(BFS,迭代)  $O(n^2)$"></a>(BFS,迭代)  $O(n^2)$</h4><p>首先使用层序遍历 BFS 写一个求节点高度的函数。</p><p>迭代法前序遍历二叉树，对于每个节点判断它的左子树和右子树的高度之差绝对值是否大于 1，如果大于 1 说明不是平衡二叉树，否则当所有节点遍历完成后，说明该树是一棵平衡二叉树。</p><h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>求二叉树的高度所需的时间为 $O(n)$，每个节点都需要求一次高度，所以时间复杂度为 $O(n^2)$。</p><h4 id="空间复杂度-1"><a href="#空间复杂度-1" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>最坏情况下每次求二叉树的高度所需系统栈空间为 $O(n)$。</p><h3 id="C-代码-1"><a href="#C-代码-1" class="headerlink" title="C++ 代码"></a>C++ 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="keyword">if</span> (root) q.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            depth ++ ;</span><br><span class="line">            <span class="type">int</span> sz = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span> (sz -- ) &#123;</span><br><span class="line">                <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (t-&gt;left) q.<span class="built_in">push</span>(t-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (t-&gt;right) q.<span class="built_in">push</span>(t-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        <span class="keyword">if</span> (root) stk.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (stk.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(<span class="built_in">getDepth</span>(t-&gt;left) - <span class="built_in">getDepth</span>(t-&gt;right)) &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (t-&gt;right) stk.<span class="built_in">push</span>(t-&gt;right);</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;left) stk.<span class="built_in">push</span>(t-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉</summary>
      
    
    
    
    <category term="算法" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指 Offer" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87-Offer/"/>
    
    
    <category term="递归" scheme="https://tonngw.com/tags/%E9%80%92%E5%BD%92/"/>
    
    <category term="迭代" scheme="https://tonngw.com/tags/%E8%BF%AD%E4%BB%A3/"/>
    
    <category term="二叉树" scheme="https://tonngw.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="DFS" scheme="https://tonngw.com/tags/DFS/"/>
    
    <category term="BFS" scheme="https://tonngw.com/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 55 - I. 二叉树的深度</title>
    <link href="https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2055%20-%20I.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/"/>
    <id>https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2055%20-%20I.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</id>
    <published>2022-07-08T14:15:03.135Z</published>
    <updated>2022-07-08T14:23:57.164Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p><p>例如：</p><p>给定二叉树 $[3,9,20,null,null,15,7]$，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br></pre></td></tr></table></figure><p>返回它的最大深度 3 。</p><p> <strong>提示：</strong> </p><ol><li>$节点总数 &lt;&#x3D; 10000$</li></ol><p>注意：本题与主站 104 题相同：<a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/</a></p><hr><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法 1"></a>算法 1</h3><h4 id="BFS-迭代-O-n"><a href="#BFS-迭代-O-n" class="headerlink" title="(BFS,迭代)  $O(n)$"></a>(BFS,迭代)  $O(n)$</h4><p>我们可以发现二叉树的最大深度正好是二叉树的层树，所以只需在层序遍历每一层的过程中记录层数即可，每多一层深度就加 $1$。</p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>二叉树中的每个节点只会被遍历一次，所以时间复杂度为 $O(n)$。</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>$O(logn)$，最坏情况下二叉树呈链状，空间复杂度为 $O(n)$</p><h3 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> sz = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span> (sz -- ) &#123;</span><br><span class="line">                <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (t-&gt;left) q.<span class="built_in">push</span>(t-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (t-&gt;right) q.<span class="built_in">push</span>(t-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res ++ ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法 2"></a>算法 2</h3><h4 id="DFS-递归-O-n"><a href="#DFS-递归-O-n" class="headerlink" title="(DFS,递归)  $O(n)$"></a>(DFS,递归)  $O(n)$</h4><ol><li>递归函数的含义：求当前树的高度（高度即最大深度）</li><li>递归的出口：如果当前节点为空节点，高度为 0</li><li>单层递归的逻辑：按后序遍历的顺序，先求左子树的高度，再求右子树的高度，最后取左右子树高度的最大值 + 1 即为当前节点的高度。</li></ol><h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>二叉树中的每个节点只会被遍历一次，所以时间复杂度为 $O(n)$。</p><h4 id="空间复杂度-1"><a href="#空间复杂度-1" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>$O(logn)$，最坏情况下二叉树呈链状，空间复杂度为 $O(n)$</p><h4 id="C-代码-1"><a href="#C-代码-1" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">maxDepth</span>(root-&gt;left), <span class="built_in">maxDepth</span>(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深</summary>
      
    
    
    
    <category term="算法" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指 Offer" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87-Offer/"/>
    
    
    <category term="递归" scheme="https://tonngw.com/tags/%E9%80%92%E5%BD%92/"/>
    
    <category term="迭代" scheme="https://tonngw.com/tags/%E8%BF%AD%E4%BB%A3/"/>
    
    <category term="二叉树" scheme="https://tonngw.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="DFS" scheme="https://tonngw.com/tags/DFS/"/>
    
    <category term="BFS" scheme="https://tonngw.com/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 54. 二叉搜索树的第k大节点</title>
    <link href="https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2054.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9/"/>
    <id>https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2054.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9/</id>
    <published>2022-07-08T14:14:57.020Z</published>
    <updated>2022-07-08T14:21:31.633Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一棵二叉搜索树，请找出其中第 $k$ 大的节点的值。</p><p> <strong>示例 1:</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [3,1,4,null,2], k = 1</span><br><span class="line">   3</span><br><span class="line">  / \</span><br><span class="line"> 1   4</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p> <strong>示例 2:</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [5,3,6,2,4,null,null,1], k = 3</span><br><span class="line">       5</span><br><span class="line">      / \</span><br><span class="line">     3   6</span><br><span class="line">    / \</span><br><span class="line">   2   4</span><br><span class="line">  /</span><br><span class="line"> 1</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p> <strong>限制：</strong> </p><ul><li>1 ≤ k ≤ 二叉搜索树元素个数</li></ul><hr><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="二叉搜索树-O-k"><a href="#二叉搜索树-O-k" class="headerlink" title="(二叉搜索树)  $O(k)$"></a>(二叉搜索树)  $O(k)$</h4><p>由于二叉搜索树的中序遍历是有序的，且是从小到大的，题目要求第 $k$ 大的值，那么可以反过来按照「右中左」的顺序遍历二叉搜索树，那么遍历到第 $k$ 个节点就是答案。</p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>最坏情况下的时间复杂度为 $O(n)$。</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>$O(1)$</p><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="type">int</span>&amp; k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!k) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right, k);</span><br><span class="line">        k -- ;</span><br><span class="line">        <span class="keyword">if</span> (!k) &#123;</span><br><span class="line">            res = root-&gt;val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode* root, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root, k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;给定一棵二叉搜索树，请找出其中第 $k$ 大的节点的值。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;示例 1:&lt;/strong&gt; &lt;/</summary>
      
    
    
    
    <category term="算法" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指 Offer" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87-Offer/"/>
    
    
    <category term="DFS" scheme="https://tonngw.com/tags/DFS/"/>
    
    <category term="二叉搜索树" scheme="https://tonngw.com/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 37. 序列化二叉树</title>
    <link href="https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2037.%20%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2037.%20%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2022-07-08T14:14:51.465Z</published>
    <updated>2022-07-08T14:22:00.081Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现两个函数，分别用来序列化和反序列化二叉树。</p><p>你需要设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 &#x2F; 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p><p> <strong>提示：</strong> 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 <a href="https://support.leetcode-cn.com/hc/kb/article/1567641/">LeetCode 序列化二叉树的格式</a>。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p><p> <strong>示例：</strong> </p><p><img src="https://blog-1255494775.cos.ap-beijing.myqcloud.com/1657082665-ZEvtif-serdeser.jpg"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3,null,null,4,5]</span><br><span class="line">输出：[1,2,3,null,null,4,5]</span><br></pre></td></tr></table></figure><p>注意：本题与主站 297 题相同：<a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/">https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/</a></p><hr><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="DFS-O-n"><a href="#DFS-O-n" class="headerlink" title="(DFS)  $O(n)$"></a>(DFS)  $O(n)$</h4><p>【1】序列化：前序遍历二叉树，对于空节点序列化为 <code>#</code>，对于非空节点将将值转换为字符串，每个节点之间用 <code>,</code> 隔开，为了反序列化判断节点边界。</p><p>【2】反序列化：根据一颗二叉树的前序序列中的非空节点和空节点可以反序列化出原二叉树。</p><ol><li>递归函数含义：<code>TreeNode* d_dfs(string&amp; s, int&amp; u)</code> $u$ 表示遍历到字符串 $s$ 的哪个位置了</li><li>递归出口条件：当字符串的所有节点都处理完自动结束</li><li>单层递归逻辑：<ul><li>如果当前字符是 $#$，则表示是空节点，直接返回空节点即可。</li><li>否则是非空节点，找出非空节点的连续值（<strong>注意</strong>：可能是多位数，或者包括负号）</li><li>创建当前节点，并递归创建它的左儿子和右儿子</li><li>最后返回当前节点<br>最后 <code>deserialize()</code> 中返回的就是二叉树的根节点</li></ul></li></ol><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>$O(n)$，每个节点只会被遍历一次。</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>$O(n)$，序列化后的字符串。</p><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">​```cpp</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string s;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">s_dfs</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            s += <span class="string">&quot;#,&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s += <span class="built_in">to_string</span>(root-&gt;val) + <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">        <span class="built_in">s_dfs</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">s_dfs</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="built_in">s_dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">d_dfs</span><span class="params">(string&amp; s, <span class="type">int</span>&amp; u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s[u] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">            u += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断负号</span></span><br><span class="line">        <span class="type">bool</span> is_minus = <span class="literal">false</span>; </span><br><span class="line">        <span class="keyword">if</span> (s[u] == <span class="string">&#x27;-&#x27;</span>) is_minus = <span class="literal">true</span>, u ++ ;</span><br><span class="line">        <span class="type">int</span> k = u;</span><br><span class="line">        <span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; s.<span class="built_in">size</span>() &amp;&amp; s[k] != <span class="string">&#x27;,&#x27;</span>) val = val * <span class="number">10</span> + (s[k ++ ] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (is_minus) val = -val;</span><br><span class="line">        </span><br><span class="line">        k ++ ;</span><br><span class="line">        u = k;</span><br><span class="line">        <span class="keyword">auto</span> root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        root-&gt;left = <span class="built_in">d_dfs</span>(s, u);</span><br><span class="line">        root-&gt;right = <span class="built_in">d_dfs</span>(s, u);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(string data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        cout &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">        <span class="type">int</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">d_dfs</span>(data, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;请实现两个函数，分别用来序列化和反序列化二叉树。&lt;/p&gt;
&lt;p&gt;你需要设计一个算法来实现二叉树的序列化与反序列化。这里不限定</summary>
      
    
    
    
    <category term="算法" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指 Offer" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87-Offer/"/>
    
    
    <category term="二叉树" scheme="https://tonngw.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="DFS" scheme="https://tonngw.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 34. 二叉树中和为某一值的路径</title>
    <link href="https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2034.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
    <id>https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2034.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</id>
    <published>2022-07-08T14:14:45.097Z</published>
    <updated>2022-07-08T14:22:53.703Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你二叉树的根节点 $root$ 和一个整数目标和 $targetSum$ ，找出所有  <strong>从根节点到叶子节点</strong>  路径总和等于给定目标和的路径。</p><p> <strong>叶子节点</strong>  是指没有子节点的节点。</p><p> <strong>示例 1：</strong> </p><p><img src="https://blog-1255494775.cos.ap-beijing.myqcloud.com/1657070274-bngmye-pathsumii1.jpg"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22</span><br><span class="line">输出：[[5,4,11,2],[5,8,4,5]]</span><br></pre></td></tr></table></figure><p> <strong>示例 2：</strong> </p><p><img src="https://blog-1255494775.cos.ap-beijing.myqcloud.com/1657070274-VrKnYT-pathsum2.jpg"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3], targetSum = 5</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p> <strong>示例 3：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2], targetSum = 0</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong> </p><ul><li>树中节点总数在范围 $[0, 5000]$ 内</li><li>$-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000$</li><li>$-1000 &lt;&#x3D; targetSum &lt;&#x3D; 1000$</li></ul><p>注意：本题与主站 113 题相同：<a href="https://leetcode-cn.com/problems/path-sum-ii/">https://leetcode-cn.com/problems/path-sum-ii/</a></p><hr><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="递归-前序遍历-O-n"><a href="#递归-前序遍历-O-n" class="headerlink" title="(递归,前序遍历)  $O(n)$"></a>(递归,前序遍历)  $O(n)$</h4><p>使用前序遍历的顺序遍历二叉树，遍历一个节点将其加入到路径数组 $path$ 中，如果当前节点是叶子节点且路径和 $sum + root-&gt;val &#x3D; target$，则说明在树中找到了一条满足路径，将当前路径加入到答案中，继续递归处理左子树和右子树，最后不要忘了 $path$ 数组回溯。</p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>$O(n)$</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>最坏情况下，叶子节点的个数为 $O(2^{n - 1})$，其中 $n$ 是二叉树的层数，每个叶子节点对应一个方案，每个方案上的节点个数是 $n$，所以总时间复杂度为 $O(n*2^{n - 1})$</p><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="type">int</span> sum, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; sum + root-&gt;val == target) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left, sum + root-&gt;val, target);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right, sum + root-&gt;val, target);</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">dfs</span>(root, <span class="number">0</span>, target);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;给你二叉树的根节点 $root$ 和一个整数目标和 $targetSum$ ，找出所有  &lt;strong&gt;从根节点到叶子节点</summary>
      
    
    
    
    <category term="算法" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指 Offer" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87-Offer/"/>
    
    
    <category term="二叉树" scheme="https://tonngw.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="DFS" scheme="https://tonngw.com/tags/DFS/"/>
    
    <category term="前序遍历" scheme="https://tonngw.com/tags/%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 33. 二叉搜索树的后序遍历序列</title>
    <link href="https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2033.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/"/>
    <id>https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2033.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/</id>
    <published>2022-07-08T14:14:36.997Z</published>
    <updated>2022-07-08T14:20:48.142Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 $true$，否则返回 $false$。假设输入的数组的任意两个数字都互不相同。</p><p>参考以下这颗二叉搜索树：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  2   6</span><br><span class="line"> / \</span><br><span class="line">1   3</span><br></pre></td></tr></table></figure><p> <strong>示例 1：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,6,3,2,5]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p> <strong>示例 2：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,2,6,5]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong> </p><ol><li>$数组长度 &lt;&#x3D; 1000$</li></ol><hr><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="二叉搜索树-DFS-O-n"><a href="#二叉搜索树-DFS-O-n" class="headerlink" title="(二叉搜索树,DFS)  $O(n)$"></a>(二叉搜索树,DFS)  $O(n)$</h4><p>根据后序序列和二叉搜索树的特性，在构造二叉搜索树（并不需要创建出真正的节点）的过程中判断是否出现矛盾，我们知道二叉搜索树的左子树的值要小于右子树，否则就不是一棵二叉搜索树。</p><p>如何构造二叉搜索树呢？</p><ol><li>根节点：后序序列的最后一个元素就是根节点</li><li>而左子树中的值都是小于根节点的，所以从前往后遍历序列就可以找到第一个大于根节点的位置 $k$，从 $[l, k - 1]$ 就是左子树，$[k, r)$ 就是右子树</li></ol><p>如何判断矛盾？</p><p>只要判断 $[k, r)$ 中的值是否都大于根节点即可</p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>$O(n)$</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>$O(n)$</p><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; postorder, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> root = postorder[r];</span><br><span class="line">        <span class="type">int</span> k = l;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; r &amp;&amp; postorder[k] &lt; root) k ++ ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = k; i &lt; r; i ++ )</span><br><span class="line">            <span class="keyword">if</span> (postorder[i] &lt; root)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(postorder, l, k - <span class="number">1</span>) &amp;&amp; <span class="built_in">dfs</span>(postorder, k, r - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">verifyPostorder</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (postorder.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(postorder, <span class="number">0</span>, postorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 $true$，否则返回 $false$。假设输入</summary>
      
    
    
    
    <category term="算法" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指 Offer" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87-Offer/"/>
    
    
    <category term="DFS" scheme="https://tonngw.com/tags/DFS/"/>
    
    <category term="二叉搜索树" scheme="https://tonngw.com/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 32 - III. 从上到下打印二叉树 III</title>
    <link href="https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2032%20-%20III.%20%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%20III/"/>
    <id>https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2032%20-%20III.%20%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%20III/</id>
    <published>2022-07-08T14:14:29.305Z</published>
    <updated>2022-07-08T14:20:06.704Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p><p>例如:<br>给定二叉树: $[3,9,20,null,null,15,7]$,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回其层次遍历结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong> </p><ol><li>$节点总数 &lt;&#x3D; 1000$</li></ol><hr><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="BFS-层序遍历-O-n"><a href="#BFS-层序遍历-O-n" class="headerlink" title="(BFS,层序遍历)  $O(n)$"></a>(BFS,层序遍历)  $O(n)$</h4><p>和 <a href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/solution/leetcode021-xi-lie-ti-jie-jian-zhi-offer-7pmz/">剑指 Offer 32 - II. 从上到下打印二叉树 II</a> 层序遍历的思路一样，只需要通过一个 $bool$ 变量在每行遍历结束之后翻转下一行的顺序即可。</p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>$O(n)$</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>$O(n)$</p><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root) q.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> zigzag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> sz = q.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; line;</span><br><span class="line">            <span class="keyword">while</span> (sz -- ) &#123;</span><br><span class="line">                <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                line.<span class="built_in">push_back</span>(t-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (t-&gt;left) q.<span class="built_in">push</span>(t-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (t-&gt;right) q.<span class="built_in">push</span>(t-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (zigzag) <span class="built_in">reverse</span>(line.<span class="built_in">begin</span>(), line.<span class="built_in">end</span>());</span><br><span class="line">            ans.<span class="built_in">push_back</span>(line);</span><br><span class="line">            zigzag = !zigzag;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的</summary>
      
    
    
    
    <category term="算法" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指 Offer" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87-Offer/"/>
    
    
    <category term="二叉树" scheme="https://tonngw.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="BFS" scheme="https://tonngw.com/tags/BFS/"/>
    
    <category term="层序遍历" scheme="https://tonngw.com/tags/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 32 - II. 从上到下打印二叉树 II</title>
    <link href="https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2032%20-%20II.%20%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%20II/"/>
    <id>https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2032%20-%20II.%20%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%20II/</id>
    <published>2022-07-08T14:14:19.925Z</published>
    <updated>2022-07-08T14:19:38.188Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p><p>例如:<br>给定二叉树: $[3,9,20,null,null,15,7]$,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回其层次遍历结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong> </p><ol><li>$节点总数 &lt;&#x3D; 1000$</li></ol><p>注意：本题与主站 102 题相同：<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">https://leetcode-cn.com/problems/binary-tree-level-order-traversal/</a></p><hr><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="BFS-层序遍历-O-n"><a href="#BFS-层序遍历-O-n" class="headerlink" title="(BFS,层序遍历)  $O(n)$"></a>(BFS,层序遍历)  $O(n)$</h4><p>使用宽度优先搜索配合队列层序遍历二叉树</p><ol><li>首先先将根节点入队列</li><li>如果队列不为空，进行以下循环</li><li>计算当前队列中的元素个数 sz，即当前层的元素个数</li><li>遍历当前层的每个元素，每次弹出队头元素，并将其对应的值加入到当前层序列中，如果当前节点有左孩子，则将左孩子入队列，如果当前节点有右孩子，则将右孩子入队列，代表下一层节点。</li><li>遍历完一层将当前层序列添加到答案中。</li></ol><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>二叉树的每个节点只会被遍历一次，所以时间复杂度为 $O(n)$。</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>存储答案需要额外 $O(n^2)$ 的空间，队列需要额外 $O(n)$ 的空间。</p><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root) q.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> sz = q.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; line;</span><br><span class="line">            <span class="keyword">while</span> (sz -- ) &#123;</span><br><span class="line">                <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                line.<span class="built_in">push_back</span>(t-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (t-&gt;left) q.<span class="built_in">push</span>(t-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (t-&gt;right) q.<span class="built_in">push</span>(t-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(line);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。&lt;/p&gt;
&lt;p&gt;例如:&lt;br&gt;给定二叉树: $[</summary>
      
    
    
    
    <category term="算法" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指 Offer" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87-Offer/"/>
    
    
    <category term="二叉树" scheme="https://tonngw.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="BFS" scheme="https://tonngw.com/tags/BFS/"/>
    
    <category term="层序遍历" scheme="https://tonngw.com/tags/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 32 - I. 从上到下打印二叉树</title>
    <link href="https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2032%20-%20I.%20%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2032%20-%20I.%20%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2022-07-08T14:14:10.843Z</published>
    <updated>2022-07-08T14:19:00.214Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p><p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p><p>例如:<br>给定的树 A:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3  </span><br><span class="line">    / \  </span><br><span class="line">   4  5  </span><br><span class="line">  / \  </span><br><span class="line"> 1   2</span><br></pre></td></tr></table></figure><p>给定的树 B：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   4   </span><br><span class="line">  /  </span><br><span class="line"> 1</span><br></pre></td></tr></table></figure><p>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</p><p> <strong>示例 1：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：A = [1,2,3], B = [3,1]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p> <strong>示例 2：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：A = [3,4,5,1,2], B = [4,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p> <strong>限制：</strong> </p><p>$0 &lt;&#x3D; 节点个数 &lt;&#x3D; 10000$</p><hr><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="DFS-暴力遍历-O-nm"><a href="#DFS-暴力遍历-O-nm" class="headerlink" title="(DFS,暴力遍历)  $O(nm)$"></a>(DFS,暴力遍历)  $O(nm)$</h4><p>算法步骤：</p><ol><li>遍历树 $root$ 中的每个节点 $s$ 都与子树 $subRoot$ 进行匹配</li><li>递归匹配子树 $s$ 和 $subRoot$ 中的每个节点，如果每个节点都相同，则匹配成功。</li></ol><p>边界：</p><ol><li>在 <code>isSubStructure()</code> 中如果 $subRoot$ 为空，题目已知空树不是任何树的子结构，所以返回 $false$。</li><li>在 <code>dfs()</code> 中，当 $q$ 为空时不需要判断 $p$ 是否为空，只要保证 $q$ 是 $p$ 的子结构即可，不需要完全匹配。</li></ol><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>树 $root$ 中的每个节点都需要与子树 $subRoot$ 进行匹配，所以时间复杂度为 $O(nm)$，$n$ 为 $root$ 的节点个数，$m$ 为 $subRoot$ 的节点个数。</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>一次匹配时最多需要 $O(max(d_1, d_2))$ 的空间复杂度，$d_1$ 表示 $root$ 的子树匹配结束时的深度，$d_2$ 表示 $subRoot$ 匹配结束时的深度。</p><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!q) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!p || p-&gt;val != q-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(p-&gt;left, q-&gt;left) &amp;&amp; <span class="built_in">dfs</span>(p-&gt;right, q-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode* root, TreeNode* subRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root || !subRoot) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dfs</span>(root, subRoot)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSubStructure</span>(root-&gt;left, subRoot) || <span class="built_in">isSubStructure</span>(root-&gt;right, subRoot);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)&lt;/p&gt;
&lt;p&gt;B是A的子结构， 即 A中有</summary>
      
    
    
    
    <category term="算法" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指 Offer" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87-Offer/"/>
    
    
    <category term="二叉树" scheme="https://tonngw.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="DFS" scheme="https://tonngw.com/tags/DFS/"/>
    
  </entry>
  
</feed>
