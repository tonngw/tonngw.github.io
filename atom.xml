<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>tonngw&#39;s Blog</title>
  
  <subtitle>开博客就要写吖！</subtitle>
  <link href="https://tonngw.com/atom.xml" rel="self"/>
  
  <link href="https://tonngw.com/"/>
  <updated>2022-07-08T14:06:55.909Z</updated>
  <id>https://tonngw.com/</id>
  
  <author>
    <name>tonngw</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剑指 Offer 59 - II. 队列的最大值</title>
    <link href="https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2059%20-%20II.%20%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <id>https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2059%20-%20II.%20%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</id>
    <published>2022-07-08T13:51:53.512Z</published>
    <updated>2022-07-08T14:06:55.909Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>请定义一个队列并实现函数 $max_value$ 得到队列里的最大值，要求函数$max_value$、$push_back$ 和 $pop_front$ 的 <strong>均摊</strong> 时间复杂度都是O(1)。</p><p>若队列为空，$pop_front$ 和 $max_value$ 需要返回 -1</p><p> <strong>示例 1：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[&quot;MaxQueue&quot;,&quot;push_back&quot;,&quot;push_back&quot;,&quot;max_value&quot;,&quot;pop_front&quot;,&quot;max_value&quot;]</span><br><span class="line">[[],[1],[2],[],[],[]]</span><br><span class="line">输出: [null,null,null,2,1,2]</span><br></pre></td></tr></table></figure><p> <strong>示例 2：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[&quot;MaxQueue&quot;,&quot;pop_front&quot;,&quot;max_value&quot;]</span><br><span class="line">[[],[],[]]</span><br><span class="line">输出: [null,-1,-1]</span><br></pre></td></tr></table></figure><p> <strong>限制：</strong> </p><ul><li>$1 &lt;&#x3D; push_back,pop_front,max_value的总操作数 &lt;&#x3D; 10000$</li><li>$1 &lt;&#x3D; value &lt;&#x3D; 10^5$</li></ul><hr><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="队列-O-n"><a href="#队列-O-n" class="headerlink" title="(队列)  $O(n)$"></a>(队列)  $O(n)$</h4><p>使用两个队列，一个普通队列 $q$ 用来存储元素，一个双端队列用来维护队列 $q$ 中的最大值。</p><ol><li><code>push_back(value)</code>: 如果 $max_q$ 的最大值小于当前值 $val$，则一直弹出队尾，然后将当前值压入队列 $q$ 和 $max_q$ 中。</li><li><code>pop_front()</code>: 弹出队列 $q$ 的队头并返回，同时如果队头正好是 $max_q$ 的队头，则 $max_q$ 也要弹出队头。</li><li><code>max_value()</code>: 返回 $max_q$ 的队头即可，队头就是最大值。</li></ol><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>$O(n)$</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>$O(n)$</p><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MaxQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; max_q;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MaxQueue</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">max_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (max_q.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> max_q.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (max_q.<span class="built_in">size</span>() &amp;&amp; max_q.<span class="built_in">back</span>() &lt; value) max_q.<span class="built_in">pop_back</span>();</span><br><span class="line">        q.<span class="built_in">push</span>(value);</span><br><span class="line">        max_q.<span class="built_in">push_back</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (q.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (t == max_q.<span class="built_in">front</span>()) max_q.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MaxQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MaxQueue* obj = new MaxQueue();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;max_value();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push_back(value);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;pop_front();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;请定义一个队列并实现函数 $max_value$ 得到队列里的最大值，要求函数$max_value$、$push_back$</summary>
      
    
    
    
    <category term="算法" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指 Offer" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87-Offer/"/>
    
    
    <category term="队列" scheme="https://tonngw.com/tags/%E9%98%9F%E5%88%97/"/>
    
    <category term="双端队列" scheme="https://tonngw.com/tags/%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 30. 包含min函数的栈</title>
    <link href="https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2030.%20%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/"/>
    <id>https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2030.%20%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</id>
    <published>2022-07-08T13:51:52.816Z</published>
    <updated>2022-07-08T14:05:16.562Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p><p> <strong>示例:</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MinStack minStack = new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.min();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.min();   --&gt; 返回 -2.</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong> </p><ol><li>各函数的调用总次数不超过 20000 次</li></ol><p>注意：本题与主站 155 题相同：<a href="https://leetcode-cn.com/problems/min-stack/">https://leetcode-cn.com/problems/min-stack/</a></p><hr><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="单调栈-O-1"><a href="#单调栈-O-1" class="headerlink" title="(单调栈)  $O(1)$"></a>(单调栈)  $O(1)$</h4><p>用一个栈 stk 维护基本的栈操作，同时需要维护一个单调栈 min_stk，用来返回栈中的最小值</p><ol><li><code>push(x)</code>: 压入 x 到基本栈 stk，同时判断单调栈 min_stk 是否为空或当前元素 x 是否小于<strong>等于</strong>当前栈顶元素，如果是，同样将 x 压入到单调栈中<blockquote><p>这里为什么相等也要入栈，是因为在 pop 的时候我们判断的条件就是如果两个栈顶相等，min_stk 也要弹出元素，所以 min_stk 中要压入 x，否则如果 stk 的最小值为有多个相等的值 x，那么 stk 和 min_stk 都弹出 x 之后，此时 stk 的最小值仍然是 x，但 min_stk 的栈顶一定小于 x，与答案不符，所以必须要压入 x</p></blockquote></li><li><code>pop()</code>: 在基本栈 stk 弹出之前，需要判断 stk 的栈顶和 min_stk 的栈顶是否相等，如果相等 min_stk 也要弹出栈顶</li><li><code>top()</code>: stk.top()</li><li><code>getMin()</code>: min_stk.top()</li></ol><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>四个操作都只有常数次入栈出栈操作，所以时间复杂度是 $O(1)$</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>$O(n)$</p><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stk, min_stk;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MinStack</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        stk.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="keyword">if</span> (min_stk.<span class="built_in">empty</span>() || min_stk.<span class="built_in">top</span>() &gt;= x) min_stk.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> t = stk.<span class="built_in">top</span>();</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (t == min_stk.<span class="built_in">top</span>()) min_stk.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stk.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min_stk.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack* obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj-&gt;min();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时</summary>
      
    
    
    
    <category term="算法" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指 Offer" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87-Offer/"/>
    
    
    <category term="单调栈" scheme="https://tonngw.com/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 59 - I. 滑动窗口的最大值</title>
    <link href="https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2059%20-%20I.%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <id>https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2059%20-%20I.%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</id>
    <published>2022-07-08T13:51:52.064Z</published>
    <updated>2022-07-08T14:07:46.643Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个数组 $nums$ 和滑动窗口的大小 $k$，请找出所有滑动窗口里的最大值。</p><p> <strong>示例:</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3</span><br><span class="line">输出: [3,3,5,5,6,7] </span><br><span class="line">解释: </span><br><span class="line"></span><br><span class="line">  滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong> </p><p>你可以假设 <em>k</em> 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。</p><p>注意：本题与主站 239 题相同：<a href="https://leetcode-cn.com/problems/sliding-window-maximum/">https://leetcode-cn.com/problems/sliding-window-maximum/</a></p><hr><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="单调队列-O-n"><a href="#单调队列-O-n" class="headerlink" title="(单调队列)  $O(n)$"></a>(单调队列)  $O(n)$</h4><p>使用单调队列求解滑动窗口中的最大值，单调队列可以用双端队列来实现，队头和队尾都可以压入和弹出元素，单调队列中存储的是<strong>元素的下标</strong>，其中队头是整个队列的最大元素的下标，从队头到队尾下标代表的元素值依次递减，这就是单调队列。</p><ol><li>遍历数组，初始状态单调队列为空，再遍历的过程中，每次插入元素前，需要判断：<br>(1) 合法性检查：队头是否已经出队，如果当前元素的下标 $i$ 到队头的距离大于等于 $k$，则队头应该出队，它已经不在当前窗口内了。<br>(2) 单调性维护：如果当前元素 <code>nums[i]</code> 大于等于队尾元素下标对应的值，那么队尾元素就再也不可能成为某个滑动窗口的最大值了，所以将满足条件的队尾都出队，始终保持队列中下标对应的元素值从队头到队尾是单调递减的。</li><li>插入当前元素的下标 $i$</li><li>当窗口中填满了数字时开始记录答案，队头下标对应的元素值就是窗口内的最大值。</li></ol><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>遍历数组的过程中，每个元素下标最多进队一次出队一次，所以时间复杂度为 $O(n)$。</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>存储单调队列需要额外 $O(k)$ 的空间，存储答案需要额外 $O(n)$ 的空间。</p><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q.<span class="built_in">size</span>() &amp;&amp; i - q.<span class="built_in">front</span>() &gt;= k) q.<span class="built_in">pop_front</span>();</span><br><span class="line">            <span class="keyword">while</span> (q.<span class="built_in">size</span>() &amp;&amp; nums[q.<span class="built_in">back</span>()] &lt; nums[i]) q.<span class="built_in">pop_back</span>();</span><br><span class="line">            q.<span class="built_in">push_back</span>(i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) res.<span class="built_in">push_back</span>(nums[q.<span class="built_in">front</span>()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;给定一个数组 $nums$ 和滑动窗口的大小 $k$，请找出所有滑动窗口里的最大值。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;示例:</summary>
      
    
    
    
    <category term="算法" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指 Offer" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87-Offer/"/>
    
    
    <category term="单调队列" scheme="https://tonngw.com/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 31. 栈的压入、弹出序列</title>
    <link href="https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2031.%20%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/"/>
    <id>https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2031.%20%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</id>
    <published>2022-07-08T13:51:51.425Z</published>
    <updated>2022-07-08T14:05:57.081Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p><p> <strong>示例 1：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：我们可以按以下顺序执行：</span><br><span class="line">push(1), push(2), push(3), push(4), pop() -&gt; 4,</span><br><span class="line">push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</span><br></pre></td></tr></table></figure><p> <strong>示例 2：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]</span><br><span class="line">输出：false</span><br><span class="line">解释：1 不能在 2 之前弹出。</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong> </p><ol><li>$0 &lt;&#x3D; pushed.length &#x3D;&#x3D; popped.length &lt;&#x3D; 1000$</li><li>$0 &lt;&#x3D; pushed[i], popped[i] &lt; 1000$</li><li>$pushed$ 是 $popped$ 的排列。</li></ol><p>注意：本题与主站 946 题相同：<a href="https://leetcode-cn.com/problems/validate-stack-sequences/">https://leetcode-cn.com/problems/validate-stack-sequences/</a></p><hr><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="栈-模拟-O-n"><a href="#栈-模拟-O-n" class="headerlink" title="(栈,模拟)  $O(n)$"></a>(栈,模拟)  $O(n)$</h4><p>使用两个序列来模拟压栈和出栈的过程，如果整个过程没有矛盾，则是一个合法的出栈序列。</p><p>算法步骤：</p><ol><li>首先定义一个栈 $stk$ 和一个指针 $i$ 用来指向出栈序列，开始模拟。</li><li>遍历压栈序列，对于每个数直接压入栈中</li><li>此时如果栈不为空且栈顶等于出栈序列中的 $poped[i]$，则把当前数弹栈，同时 $i$ 指针往后移，循环此过程。</li></ol><p>最后如果栈为空则说明整个压入弹出过程没有矛盾，返回 $true$，否则返回 $false$。</p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>每个数最多只会入栈出栈一次，所以时间复杂度为 $O(n)$。</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>$O(n)$</p><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">validateStackSequences</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; pushed, vector&lt;<span class="type">int</span>&gt;&amp; popped)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : pushed) &#123;</span><br><span class="line">            stk.<span class="built_in">push</span>(x);</span><br><span class="line">            <span class="keyword">while</span> (stk.<span class="built_in">size</span>() &amp;&amp; stk.<span class="built_in">top</span>() == popped[i]) &#123;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                i ++ ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列</summary>
      
    
    
    
    <category term="算法" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指 Offer" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87-Offer/"/>
    
    
    <category term="模拟" scheme="https://tonngw.com/tags/%E6%A8%A1%E6%8B%9F/"/>
    
    <category term="栈" scheme="https://tonngw.com/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 52. 两个链表的第一个公共节点</title>
    <link href="https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2052.%20%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/"/>
    <id>https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2052.%20%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</id>
    <published>2022-07-08T13:51:50.784Z</published>
    <updated>2022-07-08T14:04:27.374Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两个链表，找出它们的第一个公共节点。</p><p>如下面的两个链表 <strong>：</strong> </p><p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"><img src="https://blog-1255494775.cos.ap-beijing.myqcloud.com/160_statement.png"></a></p><p>在节点 c1 开始相交。</p><p> <strong>示例 1：</strong> </p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png"><img src="https://blog-1255494775.cos.ap-beijing.myqcloud.com/160_example_1.png"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3</span><br><span class="line">输出：Reference of the node with value = 8</span><br><span class="line">输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure><p> <strong>示例 2：</strong> </p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png"><img src="https://blog-1255494775.cos.ap-beijing.myqcloud.com/160_example_2.png"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1</span><br><span class="line">输出：Reference of the node with value = 2</span><br><span class="line">输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure><p> <strong>示例 3：</strong> </p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png"><img src="https://blog-1255494775.cos.ap-beijing.myqcloud.com/160_example_3.png"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2</span><br><span class="line">输出：null</span><br><span class="line">输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">解释：这两个链表不相交，因此返回 null。</span><br></pre></td></tr></table></figure><p> <strong>注意：</strong> </p><ul><li>如果两个链表没有交点，返回 $null$.</li><li>在返回结果后，两个链表仍须保持原有的结构。</li><li>可假定整个链表结构中没有循环。</li><li>程序尽量满足 O(<em>n</em>) 时间复杂度，且仅用 O(<em>1</em>) 内存。</li><li>本题与主站 160 题相同：<a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/</a></li></ul><hr><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="链表-O-n-m"><a href="#链表-O-n-m" class="headerlink" title="(链表)  $O(n + m)$"></a>(链表)  $O(n + m)$</h4><p>很巧妙的一种思想，用两个指针 $first$ 和 $second$ 分别指向两条链表 $A$ 和 $B$</p><p><code>first != second</code> 时循环进行如下操作：</p><ol><li>如果 $first$ 不为空，$first$ 往后走一步，否则 $first$ 从链表 $B$ 的头节点开始走.</li><li>如果 $second$ 不为空，$second$ 往后走一步，否则 $first$ 从链表 $A$ 的头节点开始走。</li></ol><p>可以发现 $first$ 和 $second$ 走过的总步数是相等的，如果两条链表有公共节点则在上述过程中一定会相遇，否则最终 $first$ 和 $second$ 都指向 $NULL$。</p><p>特殊情况：两条链表长度相等，如果有公共节点则在 $first$ 和 $second$ 遍历完整个链表前就会输出，否则 $first$ 和 $second$ 在遍历完当前链表后都指向 $NULL$，提前结束。</p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>最坏情况下 $first$ 和 $second$ 都会遍历一遍两条链表，时间复杂度为 $O(n + m)$。</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>$O(1)$</p><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> first = headA, second = headB;</span><br><span class="line">        <span class="keyword">while</span> (first != second) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first) first = first-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> first = headB;</span><br><span class="line">            <span class="keyword">if</span> (second) second = second-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> second = headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;输入两个链表，找出它们的第一个公共节点。&lt;/p&gt;
&lt;p&gt;如下面的两个链表 &lt;strong&gt;：&lt;/strong&gt; &lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="算法" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指 Offer" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87-Offer/"/>
    
    
    <category term="链表" scheme="https://tonngw.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 36. 二叉搜索树与双向链表</title>
    <link href="https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2036.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    <id>https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2036.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</id>
    <published>2022-07-08T13:51:50.164Z</published>
    <updated>2022-07-08T14:04:00.194Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p><p>为了让您更好地理解问题，以下面的二叉搜索树为例：</p><p><img src="https://blog-1255494775.cos.ap-beijing.myqcloud.com/1657078768-teICRh-bstdlloriginalbst.png"></p><p>我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。</p><p>下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。</p><p><img src="https://blog-1255494775.cos.ap-beijing.myqcloud.com/1657078768-zCrJJQ-bstdllreturndll.png"></p><p>特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。</p><p> <strong>注意：</strong> 本题与主站 426 题相同：<a href="https://leetcode-cn.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/">https://leetcode-cn.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/</a></p><p> <strong>注意：</strong> 此题对比原题有改动。</p><hr><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="DFS-O-n"><a href="#DFS-O-n" class="headerlink" title="(DFS)  $O(n)$"></a>(DFS)  $O(n)$</h4><p>因为二叉搜索树的中序遍历是有序的，所以选择中序遍历二叉树，在遍历的过程中将二叉搜索树转换为双向链表。</p><p>使用一个指针 pre 指向当前遍历节点的前一个节点。关键的三步操作</p><ol><li><p>前一个节点 pre 的 right 指向当前节点（注意 pre 不能为空）<code>pre-&gt;right = root</code></p></li><li><p>当前节点的 left 指向前一个节点 <code>root-&gt;left = pre</code></p></li><li><p>不要忘了 pre 指向当前节点 <code>pre = root</code></p></li></ol><p>就构成了双向关联，当然上面两步中的关联可能原二叉树中就有，但是不影响答案。</p><p>最后不要忘了双向链表的首尾相连，才能构成一个完整的双向链表。</p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>$O(n)$</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>$O(1)$</p><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = NULL;</span></span><br><span class="line"><span class="comment">        right = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Node* pre = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (pre) pre-&gt;right = root;</span><br><span class="line">        root-&gt;left = pre;</span><br><span class="line">        </span><br><span class="line">        pre = root;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">auto</span> L = root, R = root;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (L-&gt;left) L = L-&gt;left;</span><br><span class="line">        <span class="keyword">while</span> (R-&gt;right) R = R-&gt;right;</span><br><span class="line">        L-&gt;left = R, R-&gt;right = L;</span><br><span class="line">        <span class="keyword">return</span> L;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。&lt;/p</summary>
      
    
    
    
    <category term="算法" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指 Offer" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87-Offer/"/>
    
    
    <category term="链表" scheme="https://tonngw.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="DFS" scheme="https://tonngw.com/tags/DFS/"/>
    
    <category term="二叉搜索树" scheme="https://tonngw.com/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 35. 复杂链表的复制</title>
    <link href="https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2035.%20%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/"/>
    <id>https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2035.%20%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</id>
    <published>2022-07-08T13:51:49.243Z</published>
    <updated>2022-07-08T14:02:55.815Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现 $copyRandomList$ 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 $next$ 指针指向下一个节点，还有一个 $random$ 指针指向链表中的任意节点或者 $null$。</p><p> <strong>示例 1：</strong> </p><p><img src="https://blog-1255494775.cos.ap-beijing.myqcloud.com/e1.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><span class="line">输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br></pre></td></tr></table></figure><p> <strong>示例 2：</strong> </p><p><img src="https://blog-1255494775.cos.ap-beijing.myqcloud.com/e2.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [[1,1],[2,1]]</span><br><span class="line">输出：[[1,1],[2,1]]</span><br></pre></td></tr></table></figure><p> <strong>示例 3：</strong> </p><p> <strong><img src="https://blog-1255494775.cos.ap-beijing.myqcloud.com/e3.png"></strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [[3,null],[3,0],[3,null]]</span><br><span class="line">输出：[[3,null],[3,0],[3,null]]</span><br></pre></td></tr></table></figure><p> <strong>示例 4：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br><span class="line">解释：给定的链表为空（空指针），因此返回 null。</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong> </p><ul><li>$-10000 &lt;&#x3D; Node.val &lt;&#x3D; 10000$</li><li>$Node.random$ 为空（null）或指向链表中的节点。</li><li>节点数目不超过 1000 。</li></ul><p> <strong>注意：</strong> 本题与主站 138 题相同：<a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/">https://leetcode-cn.com/problems/copy-list-with-random-pointer/</a></p><hr><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h5 id="链表-模拟-O-n"><a href="#链表-模拟-O-n" class="headerlink" title="(链表,模拟)  $O(n)$"></a>(链表,模拟)  $O(n)$</h5><p>不使用额外空间，分三步处理</p><ol><li>遍历一遍链表，在每个节点的后面插入一个与当前节点值相同的节点</li><li>再遍历一遍，对于原链表中有 $random$ 域的节点进行赋值 <code>p-&gt;next-&gt;random = p-&gt;random-&gt;next</code></li><li>最后将复制出来的链表拆分出来，同时恢复原链表的结构</li></ol><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>遍历链表的时间复杂度是 $O(n)$</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>$O(1)$</p><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* random;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = NULL;</span></span><br><span class="line"><span class="comment">        random = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 复制每个节点接到它的后面</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = head; p; ) &#123;</span><br><span class="line">            <span class="keyword">auto</span> np = <span class="keyword">new</span> <span class="built_in">Node</span>(p-&gt;val);</span><br><span class="line">            <span class="keyword">auto</span> next = p-&gt;next;</span><br><span class="line">            p-&gt;next = np;</span><br><span class="line">            np-&gt;next = next;</span><br><span class="line">            p = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 为复制出来的节点的 random 域赋值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = head; p; p = p-&gt;next-&gt;next)</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;random)</span><br><span class="line">                p-&gt;next-&gt;random = p-&gt;random-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 将复制出来的链表从原链表中拆出来</span></span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">auto</span> cur = dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = head; p; p = p-&gt;next) &#123;</span><br><span class="line">            cur-&gt;next = p-&gt;next;</span><br><span class="line">            p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;请实现 $copyRandomList$ 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 $next$ 指针指向下</summary>
      
    
    
    
    <category term="算法" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指 Offer" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87-Offer/"/>
    
    
    <category term="模拟" scheme="https://tonngw.com/tags/%E6%A8%A1%E6%8B%9F/"/>
    
    <category term="链表" scheme="https://tonngw.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 26. 树的子结构</title>
    <link href="https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2026.%20%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/"/>
    <id>https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2026.%20%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</id>
    <published>2022-07-08T13:51:48.021Z</published>
    <updated>2022-07-08T14:09:11.098Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p><p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p><p>例如:<br>给定的树 A:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3  </span><br><span class="line">    / \  </span><br><span class="line">   4  5  </span><br><span class="line">  / \  </span><br><span class="line"> 1   2</span><br></pre></td></tr></table></figure><p>给定的树 B：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   4   </span><br><span class="line">  /  </span><br><span class="line"> 1</span><br></pre></td></tr></table></figure><p>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</p><p> <strong>示例 1：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：A = [1,2,3], B = [3,1]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p> <strong>示例 2：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：A = [3,4,5,1,2], B = [4,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p> <strong>限制：</strong> </p><p>$0 &lt;&#x3D; 节点个数 &lt;&#x3D; 10000$</p><hr><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="DFS-暴力遍历-O-nm"><a href="#DFS-暴力遍历-O-nm" class="headerlink" title="(DFS,暴力遍历)  $O(nm)$"></a>(DFS,暴力遍历)  $O(nm)$</h4><p>算法步骤：</p><ol><li>遍历树 $root$ 中的每个节点 $s$ 都与子树 $subRoot$ 进行匹配</li><li>递归匹配子树 $s$ 和 $subRoot$ 中的每个节点，如果每个节点都相同，则匹配成功。</li></ol><p>边界：</p><ol><li>在 <code>isSubStructure()</code> 中如果 $subRoot$ 为空，题目已知空树不是任何树的子结构，所以返回 $false$。</li><li>在 <code>dfs()</code> 中，当 $q$ 为空时不需要判断 $p$ 是否为空，只要保证 $q$ 是 $p$ 的子结构即可，不需要完全匹配。</li></ol><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>树 $root$ 中的每个节点都需要与子树 $subRoot$ 进行匹配，所以时间复杂度为 $O(nm)$，$n$ 为 $root$ 的节点个数，$m$ 为 $subRoot$ 的节点个数。</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>一次匹配时最多需要 $O(max(d_1, d_2))$ 的空间复杂度，$d_1$ 表示 $root$ 的子树匹配结束时的深度，$d_2$ 表示 $subRoot$ 匹配结束时的深度。</p><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!q) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!p || p-&gt;val != q-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(p-&gt;left, q-&gt;left) &amp;&amp; <span class="built_in">dfs</span>(p-&gt;right, q-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode* root, TreeNode* subRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root || !subRoot) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dfs</span>(root, subRoot)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSubStructure</span>(root-&gt;left, subRoot) || <span class="built_in">isSubStructure</span>(root-&gt;right, subRoot);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)&lt;/p&gt;
&lt;p&gt;B是A的子结构， 即 A中有</summary>
      
    
    
    
    <category term="算法" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指 Offer" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87-Offer/"/>
    
    
    <category term="二叉树" scheme="https://tonngw.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="DFS" scheme="https://tonngw.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 25. 合并两个排序的链表</title>
    <link href="https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2025.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/"/>
    <id>https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2025.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</id>
    <published>2022-07-08T13:51:33.775Z</published>
    <updated>2022-07-08T13:58:01.524Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p><p> <strong>示例1：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure><p> <strong>限制：</strong> </p><p>$0 &lt;&#x3D; 链表长度 &lt;&#x3D; 1000$</p><p>注意：本题与主站 21 题相同：<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">https://leetcode-cn.com/problems/merge-two-sorted-lists/</a></p><hr><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="二路归并-O-n"><a href="#二路归并-O-n" class="headerlink" title="(二路归并)  $O(n)$"></a>(二路归并)  $O(n)$</h4><p>新建一个虚拟头节点 dummy 用于存储合并两个链表后的新链表<br>根据归并的思想，两个指针 l1 和 l2 分别指向两个链表</p><ol start="0"><li>当 l1 和 l2 不为空时，循环比较两个指针指向节点的值的大小</li><li>如果 <code>l1-&gt;val &lt; l2-&gt;val</code>，把 l1 节点拿出来放到新链表的末尾，同时 l1 往后移</li><li>如果 <code>l1-&gt;val &gt;= l2-&gt;val</code>，把 l2 节点拿出来放到新链表的末尾，同时 l2 往后移</li><li>l1 和 l2 只要有一个为空循环结束，肯定有一个为空，另一个不为空，最后需要将不为空的部分接到新链表的末尾</li><li>返回虚拟节点的 next 就是新链表的真正头节点</li></ol><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>两个链表各遍历一次，所以总时间复杂度为 $O(n)$</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>$O(n)$，$n$ 为两个链表的长度之和</p><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">auto</span> cur = dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) cur-&gt;next = l1, l1 = l1-&gt;next, cur = cur-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> cur-&gt;next = l2, l2 = l2-&gt;next, cur = cur-&gt;next; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l1) cur-&gt;next = l1;</span><br><span class="line">        <span class="keyword">if</span> (l2) cur-&gt;next = l2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;示例1：&lt;/st</summary>
      
    
    
    
    <category term="算法" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指 Offer" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87-Offer/"/>
    
    
    <category term="链表" scheme="https://tonngw.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="二路归并" scheme="https://tonngw.com/tags/%E4%BA%8C%E8%B7%AF%E5%BD%92%E5%B9%B6/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 24. 反转链表</title>
    <link href="https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2024.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2024.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</id>
    <published>2022-07-08T13:51:25.246Z</published>
    <updated>2022-07-08T13:57:21.066Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p><p> <strong>示例:</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure><p> <strong>限制：</strong> </p><p>$0 &lt;&#x3D; 节点个数 &lt;&#x3D; 5000$</p><p> <strong>注意</strong> ：本题与主站 206 题相同：<a href="https://leetcode-cn.com/problems/reverse-linked-list/">https://leetcode-cn.com/problems/reverse-linked-list/</a></p><hr><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法 1"></a>算法 1</h3><h4 id="链表-迭代-O-n"><a href="#链表-迭代-O-n" class="headerlink" title="(链表,迭代)  $O(n)$"></a>(链表,迭代)  $O(n)$</h4><p>创建一个前驱节点 $pre$，初始值为 $nullptr$，使用一个指针 $cur$ 遍历链表</p><p>$cur$ 不为空执行以下操作：</p><ol><li>首先需要把当前节点的下一个节点存起来，防止链表断裂</li><li>让当前节点的 $next$ 指向前驱节点</li><li>当前节点指向下一个节点，前驱节点指向当前节点</li><li>循环以上步骤直到当前节点为 $nullptr$</li></ol><p>最终 $pre$ 存的就是翻转后链表的头节点</p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>只需遍历一遍链表，所以时间复杂度为 $O(n)$，$n$ 为链表的长度</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>$O(1)$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">auto</span> cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            <span class="keyword">auto</span> next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法 2"></a>算法 2</h3><h4 id="链表-递归-O-n"><a href="#链表-递归-O-n" class="headerlink" title="(链表,递归)  $O(n)$"></a>(链表,递归)  $O(n)$</h4><p>递归的步骤</p><ol start="0"><li>递归出口条件：如果链表为空或链表只有一个节点，则不需要翻转，直接返回头节点即可。</li><li>翻转头节点为 $head-&gt;next$ 的链表，得到尾节点 $tail$，即翻转后链表的头节点（因为以 $head-&gt;next$ 为头节点的链表和以 $head$ 为头节点的链表的尾节点是一样的）。</li><li>然后将 $head-&gt;next$ 链表的头节点的 $next$ 指向原链表的头节点，<code>head-&gt;next-&gt;next = head</code>。</li><li>最后将原链表的 $next$ 指向空</li></ol><p>最终返回翻转后链表的头节点即 $tail$</p><h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>链表中的每个节点只被遍历一遍，所以时间复杂度为 $O(n)$，$n$ 为链表的长度</p><h4 id="空间复杂度-1"><a href="#空间复杂度-1" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>递归的深度为 $n$，系统栈的空间复杂度为 $O(n)$，所以额外空间复杂度为 $O(n)$</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">auto</span> tail = <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> tail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;示例:&lt;/stro</summary>
      
    
    
    
    <category term="算法" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指 Offer" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87-Offer/"/>
    
    
    <category term="链表" scheme="https://tonngw.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="迭代" scheme="https://tonngw.com/tags/%E8%BF%AD%E4%BB%A3/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 22. 链表中倒数第k个节点</title>
    <link href="https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2022.%20%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <id>https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2022.%20%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/</id>
    <published>2022-07-08T13:50:58.596Z</published>
    <updated>2022-07-08T13:56:01.920Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p><p>例如，一个链表有 $6$ 个节点，从头节点开始，它们的值依次是 $1、2、3、4、5、6$。这个链表的倒数第 $3$ 个节点是值为 $4$ 的节点。</p><p> <strong>示例：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.</span><br><span class="line"></span><br><span class="line">返回链表 4-&gt;5.</span><br></pre></td></tr></table></figure><hr><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="双指针-快慢指针-一次扫描-O-n"><a href="#双指针-快慢指针-一次扫描-O-n" class="headerlink" title="(双指针,快慢指针,一次扫描)  $O(n)$"></a>(双指针,快慢指针,一次扫描)  $O(n)$</h4><p>使用两个指针 $first、second$，先让 $second$ 往后走 $k$ 步，此时两个指针同时往后走，当 $second$ 为空时，此时 $first$ 指针指向的就是倒数第 $k$ 个节点。</p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>$O(n)$</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>$O(1)$</p><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> first = head, second = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i ++ ) second = second-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (second) &#123;</span><br><span class="line">            first = first-&gt;next;</span><br><span class="line">            second = second-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。&lt;/p&gt;</summary>
      
    
    
    
    <category term="算法" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指 Offer" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87-Offer/"/>
    
    
    <category term="链表" scheme="https://tonngw.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="快慢指针" scheme="https://tonngw.com/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 18. 删除链表的节点</title>
    <link href="https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2018.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <id>https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2018.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/</id>
    <published>2022-07-08T13:46:51.142Z</published>
    <updated>2022-07-08T13:56:15.116Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p><p>返回删除后的链表的头节点。</p><p> <strong>注意：</strong> 此题对比原题有改动</p><p> <strong>示例 1:</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: head = [4,5,1,9], val = 5</span><br><span class="line">输出: [4,1,9]</span><br><span class="line">解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span><br></pre></td></tr></table></figure><p> <strong>示例 2:</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: head = [4,5,1,9], val = 1</span><br><span class="line">输出: [4,5,9]</span><br><span class="line">解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</span><br></pre></td></tr></table></figure><p> <strong>说明：</strong> </p><ul><li>题目保证链表中节点的值互不相同</li><li>若使用 C 或 C++ 语言，你不需要 $free$ 或 $delete$ 被删除的节点</li></ul><hr><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="链表-O-n"><a href="#链表-O-n" class="headerlink" title="(链表)  $O(n)$"></a>(链表)  $O(n)$</h4><p>要删除指定值的节点，那么头节点也可能被删除，所以建立一个虚拟头节点 $dummy$ 和两个指针 $p、q$，$p$ 指向当前遍历节点的前一个位置，$q$ 指向当前节点，遍历链表如果当前节点的值等于 $val$ 则删除 <code>p-&gt;next = q-&gt;next</code>，否则继续往后找。</p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>$O(n)$</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>$O(n)$</p><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteNode</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> p = dummy, q = p-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (q)</span><br><span class="line">            <span class="keyword">if</span> (q-&gt;val == val) &#123;</span><br><span class="line">                p-&gt;next = q-&gt;next;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p = q, q = q-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。&lt;/p&gt;
&lt;p&gt;返回删除后的链表的头节点。&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="算法" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指 Offer" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87-Offer/"/>
    
    
    <category term="链表" scheme="https://tonngw.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 12. 矩阵中的路径</title>
    <link href="https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2012.%20%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
    <id>https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2012.%20%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</id>
    <published>2022-07-08T13:46:08.870Z</published>
    <updated>2022-07-08T13:48:35.796Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个 $m x n$ 二维字符网格 $board$ 和一个字符串单词 $word$ 。如果 $word$ 存在于网格中，返回 $true$ ；否则，返回 $false$ 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p>例如，在下面的 3×4 的矩阵中包含单词 “ABCCED”（单词中的字母已标出）。</p><p><img src="https://blog-1255494775.cos.ap-beijing.myqcloud.com/1656380717-UQIzDD-word2.jpg"></p><p> <strong>示例 1：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p> <strong>示例 2：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], word = &quot;abcd&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong> </p><ul><li>$1 &lt;&#x3D; board.length &lt;&#x3D; 200$</li><li>$1 &lt;&#x3D; board[i].length &lt;&#x3D; 200$</li><li>$board$ 和 $word$ 仅由大小写英文字母组成</li></ul><p> <strong>注意：</strong> 本题与主站 79 题相同：<a href="https://leetcode-cn.com/problems/word-search/">https://leetcode-cn.com/problems/word-search/</a></p><hr><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="DFS-回溯-O-nm-3-k"><a href="#DFS-回溯-O-nm-3-k" class="headerlink" title="(DFS,回溯)  $O(nm*3^k)$"></a>(DFS,回溯)  $O(nm*3^k)$</h4><p>从图中每个点作为起点开始搜索长度为 $word.size()$ 的序列，如果匹配成功则返回 $true$，否则从下一个点开始搜索，直到所有点作为起点都没有匹配成功，则返回 $false$。</p><p>搜索的逻辑：</p><ol><li>递归函数的含义：<code>bool dfs(int x, int y, int u, string word)</code>，$(x, y)$ 表示当前正在搜索的坐标，$u$ 表示当前正在匹配 $word$ 中的哪个字母。</li><li>递归的出口条件：如果当前坐标上的值和 $word$ 的第 $u$ 个字母不匹配则返回 $false$，如果当前匹配完了 $word$ 的最后一个字母，则返回 $true$。</li><li>单层递归的逻辑：如果当前字母匹配成功，则标记已访问，并开始匹配下一个字母，依次枚举剩下的三个方向，继续递归匹配，如果匹配成功，则返回 $true$，否则三个方向都匹配失败返回 $false$。</li></ol><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>$O(nm<em>3^k)$，$DFS$ 搜索的时间为 $3^k$，$k$ 表示字符串的长度，最坏情况下每个点都要作为起点搜一遍，所以时间复杂度为 $O(nm</em>3^k)$。</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>$O(nm)$</p><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">char</span>&gt;&gt; g;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; st;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> u, string word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (g[x][y] != word[u]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (u == word.<span class="built_in">size</span>() - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        st[x][y] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ ) &#123;</span><br><span class="line">            <span class="type">int</span> a = x + dx[i], b = y + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= n || b &lt; <span class="number">0</span> || b &gt;= m || st[a][b]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dfs</span>(a, b, u + <span class="number">1</span>, word)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        st[x][y] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">        g = board;</span><br><span class="line">        n = g.<span class="built_in">size</span>(), m = g[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        st = vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m, <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">dfs</span>(i, j, <span class="number">0</span>, word)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;给定一个 $m x n$ 二维字符网格 $board$ 和一个字符串单词 $word$ 。如果 $word$ 存在于网格中，</summary>
      
    
    
    
    <category term="算法" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指 Offer" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87-Offer/"/>
    
    
    <category term="搜索" scheme="https://tonngw.com/tags/%E6%90%9C%E7%B4%A2/"/>
    
    <category term="DFS" scheme="https://tonngw.com/tags/DFS/"/>
    
    <category term="回溯" scheme="https://tonngw.com/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 11. 旋转数组的最小数字</title>
    <link href="https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2011.%20%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
    <id>https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2011.%20%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</id>
    <published>2022-07-08T13:45:52.237Z</published>
    <updated>2022-07-08T13:50:01.932Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</p><p>给你一个可能存在  <strong>重复</strong>  元素值的数组 $numbers$ ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的 <strong>最小元素</strong> 。例如，数组 $[3,4,5,1,2]$ 为 $[1,2,3,4,5]$ 的一次旋转，该数组的最小值为 1。  </p><p>注意，数组 $[a[0], a[1], a[2], …, a[n-1]]$ 旋转一次 的结果为数组 $[a[n-1], a[0], a[1], a[2], …, a[n-2]]$ 。</p><p> <strong>示例 1：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：numbers = [3,4,5,1,2]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p> <strong>示例 2：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：numbers = [2,2,2,0,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong> </p><ul><li>$n &#x3D;&#x3D; numbers.length$</li><li>$1 &lt;&#x3D; n &lt;&#x3D; 5000$</li><li>$-5000 &lt;&#x3D; numbers[i] &lt;&#x3D; 5000$</li><li>$numbers$ 原来是一个升序排序的数组，并进行了 $1$ 至 $n$ 次旋转</li></ul><p>注意：本题与主站 154 题相同：<a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/">https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/</a></p><hr><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="二分-O-n"><a href="#二分-O-n" class="headerlink" title="(二分)  $O(n)$"></a>(二分)  $O(n)$</h4><p>题目已知原来是一个非严格升序数组，有序性我们可以想到二分，经过旋转后原数组前一半有序后一半有序，但整体是无序的，但仍然可以用二分，二分只要满足两段性就可以使用，观察旋转后的数组前一半都是大于 $nums[0]$ 的后一半都是小于 $nums[0]$ 的，只要后面是小于 $nums[0]$ 的就可以二分答案。</p><p>算法步骤：</p><ol><li>首先判断首尾是否相等，如果相等，则去掉尾部和 $nums[0]$ 相等的元素，为了可以二分答案。</li><li>如果当前数组已经有序，说明最小值就是 $nums[0]$。</li><li>否则二分答案，这里既可以二分最大值的位置，加 $1$ 就是答案，也可以直接二分最小值的位置。</li></ol><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>最坏情况下，如果数组中的值都是相等的，则需要遍历每个数，时间复杂度是 $O(n)$ 的，虽然二分的时间复杂度是 $logn$，但总时间复杂度为 $O(n)$。</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>$O(1)$</p><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><p>二分最小值位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &amp;&amp; nums[<span class="number">0</span>] == nums[n]) n -- ;</span><br><span class="line">        <span class="keyword">if</span> (!n || nums[<span class="number">0</span>] &lt; nums[n]) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = n;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; nums[<span class="number">0</span>]) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[r];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>二分最大值位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &amp;&amp; nums[<span class="number">0</span>] == nums[n]) n -- ;</span><br><span class="line">        <span class="keyword">if</span> (!n || nums[<span class="number">0</span>] &lt; nums[n]) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = n;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= nums[<span class="number">0</span>]) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[r + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。&lt;/p&gt;
&lt;p&gt;给你一个可能存在  &lt;strong&gt;重复&lt;</summary>
      
    
    
    
    <category term="算法" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指 Offer" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87-Offer/"/>
    
    
    <category term="二分" scheme="https://tonngw.com/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 10- II. 青蛙跳台阶问题</title>
    <link href="https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2010-%20II.%20%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/"/>
    <id>https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2010-%20II.%20%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/</id>
    <published>2022-07-08T13:20:39.235Z</published>
    <updated>2022-07-08T13:44:34.336Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 $n$ 级的台阶总共有多少种跳法。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p> <strong>示例 1：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p> <strong>示例 2：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 7</span><br><span class="line">输出：21</span><br></pre></td></tr></table></figure><p> <strong>示例 3：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 0</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong> </p><ul><li>$0 &lt;&#x3D; n &lt;&#x3D; 100$</li></ul><p>注意：本题与主站 70 题相同：<a href="https://leetcode-cn.com/problems/climbing-stairs/">https://leetcode-cn.com/problems/climbing-stairs/</a></p><hr><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="动态规划-O-n"><a href="#动态规划-O-n" class="headerlink" title="(动态规划))  $O(n)$"></a>(动态规划))  $O(n)$</h4><p>状态表示：$f[i]$，表示青蛙跳到第 $i$ 级台阶的所有跳法。</p><p>状态计算：按照最后一步是如何跳到第 $i$ 级台阶的分情况讨论：</p><ol><li>从第 $i - 1$ 层跳过来</li><li>从第 $i - 2$ 层跳过来</li></ol><p>所以 $f[i] &#x3D; f[i - 1] + f[i - 2]$。</p><p>边界：</p><ol><li>初始化：$f[1] &#x3D; 1, f[2] &#x3D; 2$，特判：如果 $n &#x3D; 0$ 则返回 $1$。</li><li>答案：$f[n]$。</li></ol><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>$O(n)$</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>$O(n)$</p><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numWays</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        f[<span class="number">1</span>] = <span class="number">1</span>, f[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i ++ ) </span><br><span class="line">            f[i] = (f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>]) % mod;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 $n$ 级的台阶总共有多少种跳法。&lt;/p&gt;
&lt;p&gt;答案需</summary>
      
    
    
    
    <category term="算法" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指 Offer" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87-Offer/"/>
    
    
    <category term="动态规划" scheme="https://tonngw.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 10- I. 斐波那契数列</title>
    <link href="https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2010-%20I.%20%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
    <id>https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2010-%20I.%20%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</id>
    <published>2022-07-08T13:20:28.444Z</published>
    <updated>2022-07-08T13:36:45.732Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>写一个函数，输入 $n$ ，求斐波那契（Fibonacci）数列的第 $n$ 项（即 $F(N)$）。斐波那契数列的定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F(0) = 0,   F(1) = 1</span><br><span class="line">F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br></pre></td></tr></table></figure><p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p> <strong>示例 1：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p> <strong>示例 2：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 5</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong> </p><ul><li>$0 &lt;&#x3D; n &lt;&#x3D; 100$</li></ul><hr><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法 1"></a>算法 1</h3><h4 id="迭代-O-n"><a href="#迭代-O-n" class="headerlink" title="(迭代)  $O(n)$"></a>(迭代)  $O(n)$</h4><p>$a$ 存放 $fib(n)$ 的结果，$b$ 存放 $fib(n + 1)$ 的结果。</p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>$O(n)$</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>$O(1)$</p><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n -- ) &#123;</span><br><span class="line">            <span class="type">int</span> c = a + b;</span><br><span class="line">            a = b, b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="算法-2-（超时）"><a href="#算法-2-（超时）" class="headerlink" title="算法 2 （超时）"></a>算法 2 （超时）</h3><h4 id="递归-O-2-n"><a href="#递归-O-2-n" class="headerlink" title="(递归)  $O(2^n)$"></a>(递归)  $O(2^n)$</h4><p>递归的逻辑：</p><ul><li><code>n &lt;= 1</code>，直接返回 $n$</li><li>否则返回 $fib(n - 1) + fib(n - 2)$</li></ul><h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>$O(2^n)$</p><h4 id="空间复杂度-1"><a href="#空间复杂度-1" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>递归系统栈所需空间 $O(n)$。</p><h4 id="C-代码-1"><a href="#C-代码-1" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n -- ) &#123;</span><br><span class="line">            <span class="type">int</span> c = a + b;</span><br><span class="line">            a = b, b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;写一个函数，输入 $n$ ，求斐波那契（Fibonacci）数列的第 $n$ 项（即 $F(N)$）。斐波那契数列的定义如下</summary>
      
    
    
    
    <category term="算法" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指 Offer" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87-Offer/"/>
    
    
    <category term="递归" scheme="https://tonngw.com/tags/%E9%80%92%E5%BD%92/"/>
    
    <category term="迭代" scheme="https://tonngw.com/tags/%E8%BF%AD%E4%BB%A3/"/>
    
    <category term="动态规划" scheme="https://tonngw.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 07. 重建二叉树</title>
    <link href="https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2007.%20%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2007.%20%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2022-07-08T13:18:30.201Z</published>
    <updated>2022-07-08T13:44:24.910Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。</p><p>假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><p> <strong>示例 1:</strong> </p><p><img src="https://blog-1255494775.cos.ap-beijing.myqcloud.com/1654057770-cUhnzq-tree.jpg"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]</span><br><span class="line">Output: [3,9,20,null,null,15,7]</span><br></pre></td></tr></table></figure><p> <strong>示例 2:</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: preorder = [-1], inorder = [-1]</span><br><span class="line">Output: [-1]</span><br></pre></td></tr></table></figure><p> <strong>限制：</strong> </p><p>$0 &lt;&#x3D; 节点个数 &lt;&#x3D; 5000$</p><p> <strong>注意</strong> ：本题与主站 105 题重复：<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</a></p><hr><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="递归-O-n"><a href="#递归-O-n" class="headerlink" title="(递归))  $O(n)$"></a>(递归))  $O(n)$</h4><p>由数据结构的知识可知根据二叉树的前序遍历和中序遍历可以唯一确定一棵二叉树。</p><p>首先定义一个哈希表 $pos$，存储中序序列中每个元素出现的位置，用于前序序列中的元素定位在中序序列中的位置，前序序列的遍历顺序是 <strong>根左右</strong>，那么第一个元素就是整棵树的根节点，而中序序列的遍历顺序是 <strong>左根右</strong>，通过哈希表 $pos$ 可以知道根节点在中序序列中的位置，同时确定左子树和右子树的范围，从而确定在前序序列中左子树和右子树的范围。同样的逻辑，递归的处理下去，就可以得到二叉树的结构。</p><p>算法步骤：</p><ol><li>预处理中序序列中每个元素出现的位置，存到哈希表中</li><li>由前序序列得到根节点的值，创建根节点，定位根节点在中序序列中的位置，确定左右子树的范围。</li><li>递归处理左子树</li><li>递归处理右子树</li></ol><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>每次递归会创建一个节点，总共 $n$ 个节点，所以总时间复杂度为 $O(n)$。</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>哈希表存储中序序列需要 $O(n)$ 的空间。</p><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    unordered_map&lt;int, int&gt; pos;</span><br><span class="line"></span><br><span class="line">    TreeNode* build(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder, int pl, int pr, int il, int ir) &#123;</span><br><span class="line">        if (pl &gt; pr) return nullptr;</span><br><span class="line">        int k = pos[preorder[pl]];</span><br><span class="line">        auto root = new TreeNode(inorder[k]);</span><br><span class="line">        root-&gt;left = build(preorder, inorder, pl + 1, pl + k - il, il, k - 1);</span><br><span class="line">        root-&gt;right = build(preorder, inorder, pl + k - il + 1, pr, k + 1, ir);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;</span><br><span class="line">        if (preorder.empty()) return nullptr;</span><br><span class="line">        for (int i = 0; i &lt; inorder.size(); i ++ ) pos[inorder[i]] = i;</span><br><span class="line">        return build(preorder, inorder, 0, preorder.size() - 1, 0, inorder.size() - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。&lt;/p&gt;
&lt;p&gt;假设输入的前序遍历和中序遍历的结果中都</summary>
      
    
    
    
    <category term="算法" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指 Offer" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87-Offer/"/>
    
    
    <category term="递归" scheme="https://tonngw.com/tags/%E9%80%92%E5%BD%92/"/>
    
    <category term="二叉树" scheme="https://tonngw.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 06. 从尾到头打印链表</title>
    <link href="https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2006.%20%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <id>https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2006.%20%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</id>
    <published>2022-07-08T13:18:30.197Z</published>
    <updated>2022-07-08T13:31:33.332Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><p> <strong>示例 1：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,3,2]</span><br><span class="line">输出：[2,3,1]</span><br></pre></td></tr></table></figure><p> <strong>限制：</strong> </p><p>$0 &lt;&#x3D; 链表长度 &lt;&#x3D; 10000$</p><hr><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法 1"></a>算法 1</h3><h4 id="迭代-O-n"><a href="#迭代-O-n" class="headerlink" title="(迭代)  $O(n)$"></a>(迭代)  $O(n)$</h4><p>从前往后遍历链表，存储每个节点的值到答案数组中，然后反转答案数组就是从尾到头打印链表的结果。</p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>$O(n)$</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>$O(n)$</p><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = head; p; p = p-&gt;next) res.<span class="built_in">push_back</span>(p-&gt;val);</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法 2"></a>算法 2</h3><h4 id="递归-O-n"><a href="#递归-O-n" class="headerlink" title="(递归)  $O(n)$"></a>(递归)  $O(n)$</h4><p>递归的出口条件：当前节点为空，返回空数组<br>递归逻辑：先递归到最后一个节点，然后从最后一个节点开始将节点值存储到答案数组中，递归函数不断弹栈，最后答案数组中存储的就是从尾到头打印链表的结果。</p><h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>$O(n)$</p><h4 id="空间复杂度-1"><a href="#空间复杂度-1" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>存储答案的空间 $O(n)$，包含递归系统栈所需的空间 $O(n)$。</p><h4 id="C-代码-1"><a href="#C-代码-1" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">reversePrint</span>(head-&gt;next);</span><br><span class="line">        res.<span class="built_in">push_back</span>(head-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;示例 1：&lt;/stro</summary>
      
    
    
    
    <category term="算法" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指 Offer" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87-Offer/"/>
    
    
    <category term="链表" scheme="https://tonngw.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="递归" scheme="https://tonngw.com/tags/%E9%80%92%E5%BD%92/"/>
    
    <category term="迭代" scheme="https://tonngw.com/tags/%E8%BF%AD%E4%BB%A3/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 09. 用两个栈实现队列</title>
    <link href="https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2009.%20%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2009.%20%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</id>
    <published>2022-07-08T13:18:30.193Z</published>
    <updated>2022-07-08T13:34:06.706Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 $appendTail$ 和 $deleteHead$ ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，$deleteHead$ 操作返回 -1 )</p><p> <strong>示例 1：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[3],[],[]]</span><br><span class="line">输出：[null,null,3,-1]</span><br></pre></td></tr></table></figure><p> <strong>示例 2：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[],[5],[2],[],[]]</span><br><span class="line">输出：[null,-1,null,null,5,2]</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong> </p><ul><li>$1 &lt;&#x3D; values &lt;&#x3D; 10000$</li><li>$最多会对 appendTail、deleteHead 进行 10000 次调用$</li></ul><hr><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="辅助栈-O-n"><a href="#辅助栈-O-n" class="headerlink" title="(辅助栈))  $O(n)$"></a>(辅助栈))  $O(n)$</h4><p>一个主栈 $stk$ 用于存储队列元素，一个辅助栈 $cache$ 用于暂存中间状态</p><ol><li><code>appendTail(val)</code>：直接将 $val$ 压入到 $stk$ 中</li><li><code>deleteHead()</code>：先将 $stk$ 中的元素弹到 $cache$ 中，此时 $cache$ 的栈顶就是队列的队头，删除即可。</li></ol><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>$O(n)$</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>$O(n)$</p><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stk, cache;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CQueue</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">appendTail</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        stk.<span class="built_in">push</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stk.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (stk.<span class="built_in">size</span>()) cache.<span class="built_in">push</span>(stk.<span class="built_in">top</span>()), stk.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> val = cache.<span class="built_in">top</span>();</span><br><span class="line">        cache.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">while</span> (cache.<span class="built_in">size</span>()) stk.<span class="built_in">push</span>(cache.<span class="built_in">top</span>()), cache.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CQueue* obj = new CQueue();</span></span><br><span class="line"><span class="comment"> * obj-&gt;appendTail(value);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;deleteHead();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 $appendTail$ 和 $deleteHead$ ，分别完成</summary>
      
    
    
    
    <category term="算法" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指 Offer" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87-Offer/"/>
    
    
    <category term="栈" scheme="https://tonngw.com/tags/%E6%A0%88/"/>
    
    <category term="队列" scheme="https://tonngw.com/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 05. 替换空格</title>
    <link href="https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2005.%20%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
    <id>https://tonngw.com/2022/07/08/%E5%89%91%E6%8C%87%20Offer/%E5%89%91%E6%8C%87%20Offer%2005.%20%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</id>
    <published>2022-07-08T13:16:46.819Z</published>
    <updated>2022-07-08T13:24:44.675Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数，把字符串 $s$ 中的每个空格替换成”%20”。</p><p> <strong>示例 1：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br></pre></td></tr></table></figure><p> <strong>限制：</strong> </p><p>$0 &lt;&#x3D; s 的长度 &lt;&#x3D; 10000$</p><hr><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="模拟-O-n"><a href="#模拟-O-n" class="headerlink" title="(模拟)  $O(n)$"></a>(模拟)  $O(n)$</h4><p>创建一个答案字符串 $res$，遍历原字符串，如果是空格则加 $%20$，否则加当前字符。</p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>$O(n)$</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>$O(n)$</p><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : s)</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27; &#x27;</span>) res += <span class="string">&quot;%20&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> res += c;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;请实现一个函数，把字符串 $s$ 中的每个空格替换成”%20”。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;示例 1：&lt;/strong</summary>
      
    
    
    
    <category term="算法" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指 Offer" scheme="https://tonngw.com/categories/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87-Offer/"/>
    
    
    <category term="模拟" scheme="https://tonngw.com/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
</feed>
